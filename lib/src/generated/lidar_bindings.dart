// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for the LiDAR SDK.
///
/// Regenerate bindings with `dart run ffigen --lidar ffigen.yaml -v severe`.
///
class LidarBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LidarBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LidarBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Load sick_scan_xd api library (dll or so file)
  int SickScanApiLoadLibrary(
    ffi.Pointer<ffi.Char> library_filepath,
  ) {
    return _SickScanApiLoadLibrary(
      library_filepath,
    );
  }

  late final _SickScanApiLoadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'SickScanApiLoadLibrary');
  late final _SickScanApiLoadLibrary = _SickScanApiLoadLibraryPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>)>();

  /// Unload sick_scan_xd api library
  int SickScanApiUnloadLibrary() {
    return _SickScanApiUnloadLibrary();
  }

  late final _SickScanApiUnloadLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
          'SickScanApiUnloadLibrary');
  late final _SickScanApiUnloadLibrary =
      _SickScanApiUnloadLibraryPtr.asFunction<int Function()>();

  /// Create an instance of sick_scan_xd api.
  /// Optional commandline arguments argc, argv identical to sick_generic_caller.
  /// Call SickScanApiInitByLaunchfile or SickScanApiInitByCli to process a lidar.
  SickScanApiHandle SickScanApiCreate(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _SickScanApiCreate(
      argc,
      argv,
    );
  }

  late final _SickScanApiCreatePtr = _lookup<
      ffi.NativeFunction<
          SickScanApiHandle Function(ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SickScanApiCreate');
  late final _SickScanApiCreate = _SickScanApiCreatePtr.asFunction<
      SickScanApiHandle Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Release and free all resources of a handle; the handle is invalid after SickScanApiRelease
  int SickScanApiRelease(
    SickScanApiHandle apiHandle,
  ) {
    return _SickScanApiRelease(
      apiHandle,
    );
  }

  late final _SickScanApiReleasePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SickScanApiHandle)>>(
          'SickScanApiRelease');
  late final _SickScanApiRelease =
      _SickScanApiReleasePtr.asFunction<int Function(SickScanApiHandle)>();

  /// Initializes a lidar by launchfile and starts message receiving and processing
  int SickScanApiInitByLaunchfile(
    SickScanApiHandle apiHandle,
    ffi.Pointer<ffi.Char> launchfile_args,
  ) {
    return _SickScanApiInitByLaunchfile(
      apiHandle,
      launchfile_args,
    );
  }

  late final _SickScanApiInitByLaunchfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              ffi.Pointer<ffi.Char>)>>('SickScanApiInitByLaunchfile');
  late final _SickScanApiInitByLaunchfile = _SickScanApiInitByLaunchfilePtr
      .asFunction<int Function(SickScanApiHandle, ffi.Pointer<ffi.Char>)>();

  /// Initializes a lidar by commandline arguments and starts message receiving and processing
  int SickScanApiInitByCli(
    SickScanApiHandle apiHandle,
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _SickScanApiInitByCli(
      apiHandle,
      argc,
      argv,
    );
  }

  late final _SickScanApiInitByCliPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle, ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('SickScanApiInitByCli');
  late final _SickScanApiInitByCli = _SickScanApiInitByCliPtr.asFunction<
      int Function(
          SickScanApiHandle, int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Stops message receiving and processing and closes a lidar
  int SickScanApiClose(
    SickScanApiHandle apiHandle,
  ) {
    return _SickScanApiClose(
      apiHandle,
    );
  }

  late final _SickScanApiClosePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SickScanApiHandle)>>(
          'SickScanApiClose');
  late final _SickScanApiClose =
      _SickScanApiClosePtr.asFunction<int Function(SickScanApiHandle)>();

  /// Register / deregister a callback for cartesian PointCloud messages, pointcloud in cartesian coordinates with fields x, y, z, intensity
  int SickScanApiRegisterCartesianPointCloudMsg(
    SickScanApiHandle apiHandle,
    SickScanPointCloudMsgCallback callback,
  ) {
    return _SickScanApiRegisterCartesianPointCloudMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterCartesianPointCloudMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanPointCloudMsgCallback)>>(
      'SickScanApiRegisterCartesianPointCloudMsg');
  late final _SickScanApiRegisterCartesianPointCloudMsg =
      _SickScanApiRegisterCartesianPointCloudMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanPointCloudMsgCallback)>();

  int SickScanApiDeregisterCartesianPointCloudMsg(
    SickScanApiHandle apiHandle,
    SickScanPointCloudMsgCallback callback,
  ) {
    return _SickScanApiDeregisterCartesianPointCloudMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterCartesianPointCloudMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanPointCloudMsgCallback)>>(
      'SickScanApiDeregisterCartesianPointCloudMsg');
  late final _SickScanApiDeregisterCartesianPointCloudMsg =
      _SickScanApiDeregisterCartesianPointCloudMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanPointCloudMsgCallback)>();

  /// Register / deregister a callback for polar PointCloud messages, pointcloud in polar coordinates with fields range, azimuth, elevation, intensity
  int SickScanApiRegisterPolarPointCloudMsg(
    SickScanApiHandle apiHandle,
    SickScanPointCloudMsgCallback callback,
  ) {
    return _SickScanApiRegisterPolarPointCloudMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterPolarPointCloudMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanPointCloudMsgCallback)>>(
      'SickScanApiRegisterPolarPointCloudMsg');
  late final _SickScanApiRegisterPolarPointCloudMsg =
      _SickScanApiRegisterPolarPointCloudMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanPointCloudMsgCallback)>();

  int SickScanApiDeregisterPolarPointCloudMsg(
    SickScanApiHandle apiHandle,
    SickScanPointCloudMsgCallback callback,
  ) {
    return _SickScanApiDeregisterPolarPointCloudMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterPolarPointCloudMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanPointCloudMsgCallback)>>(
      'SickScanApiDeregisterPolarPointCloudMsg');
  late final _SickScanApiDeregisterPolarPointCloudMsg =
      _SickScanApiDeregisterPolarPointCloudMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanPointCloudMsgCallback)>();

  /// Register / deregister a callback for Imu messages
  int SickScanApiRegisterImuMsg(
    SickScanApiHandle apiHandle,
    SickScanImuMsgCallback callback,
  ) {
    return _SickScanApiRegisterImuMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterImuMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanImuMsgCallback)>>('SickScanApiRegisterImuMsg');
  late final _SickScanApiRegisterImuMsg = _SickScanApiRegisterImuMsgPtr
      .asFunction<int Function(SickScanApiHandle, SickScanImuMsgCallback)>();

  int SickScanApiDeregisterImuMsg(
    SickScanApiHandle apiHandle,
    SickScanImuMsgCallback callback,
  ) {
    return _SickScanApiDeregisterImuMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterImuMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanImuMsgCallback)>>('SickScanApiDeregisterImuMsg');
  late final _SickScanApiDeregisterImuMsg = _SickScanApiDeregisterImuMsgPtr
      .asFunction<int Function(SickScanApiHandle, SickScanImuMsgCallback)>();

  /// Register / deregister a callback for SickScanLFErecMsg messages
  int SickScanApiRegisterLFErecMsg(
    SickScanApiHandle apiHandle,
    SickScanLFErecMsgCallback callback,
  ) {
    return _SickScanApiRegisterLFErecMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterLFErecMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanLFErecMsgCallback)>>('SickScanApiRegisterLFErecMsg');
  late final _SickScanApiRegisterLFErecMsg = _SickScanApiRegisterLFErecMsgPtr
      .asFunction<int Function(SickScanApiHandle, SickScanLFErecMsgCallback)>();

  int SickScanApiDeregisterLFErecMsg(
    SickScanApiHandle apiHandle,
    SickScanLFErecMsgCallback callback,
  ) {
    return _SickScanApiDeregisterLFErecMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterLFErecMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanLFErecMsgCallback)>>('SickScanApiDeregisterLFErecMsg');
  late final _SickScanApiDeregisterLFErecMsg =
      _SickScanApiDeregisterLFErecMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanLFErecMsgCallback)>();

  /// Register / deregister a callback for SickScanLIDoutputstateMsg messages
  int SickScanApiRegisterLIDoutputstateMsg(
    SickScanApiHandle apiHandle,
    SickScanLIDoutputstateMsgCallback callback,
  ) {
    return _SickScanApiRegisterLIDoutputstateMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterLIDoutputstateMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanLIDoutputstateMsgCallback)>>(
      'SickScanApiRegisterLIDoutputstateMsg');
  late final _SickScanApiRegisterLIDoutputstateMsg =
      _SickScanApiRegisterLIDoutputstateMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanLIDoutputstateMsgCallback)>();

  int SickScanApiDeregisterLIDoutputstateMsg(
    SickScanApiHandle apiHandle,
    SickScanLIDoutputstateMsgCallback callback,
  ) {
    return _SickScanApiDeregisterLIDoutputstateMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterLIDoutputstateMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanLIDoutputstateMsgCallback)>>(
      'SickScanApiDeregisterLIDoutputstateMsg');
  late final _SickScanApiDeregisterLIDoutputstateMsg =
      _SickScanApiDeregisterLIDoutputstateMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanLIDoutputstateMsgCallback)>();

  /// Register / deregister a callback for SickScanRadarScan messages
  int SickScanApiRegisterRadarScanMsg(
    SickScanApiHandle apiHandle,
    SickScanRadarScanCallback callback,
  ) {
    return _SickScanApiRegisterRadarScanMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterRadarScanMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanRadarScanCallback)>>('SickScanApiRegisterRadarScanMsg');
  late final _SickScanApiRegisterRadarScanMsg =
      _SickScanApiRegisterRadarScanMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanRadarScanCallback)>();

  int SickScanApiDeregisterRadarScanMsg(
    SickScanApiHandle apiHandle,
    SickScanRadarScanCallback callback,
  ) {
    return _SickScanApiDeregisterRadarScanMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterRadarScanMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanRadarScanCallback)>>('SickScanApiDeregisterRadarScanMsg');
  late final _SickScanApiDeregisterRadarScanMsg =
      _SickScanApiDeregisterRadarScanMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanRadarScanCallback)>();

  /// Register / deregister a callback for SickScanLdmrsObjectArray messages
  int SickScanApiRegisterLdmrsObjectArrayMsg(
    SickScanApiHandle apiHandle,
    SickScanLdmrsObjectArrayCallback callback,
  ) {
    return _SickScanApiRegisterLdmrsObjectArrayMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterLdmrsObjectArrayMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanLdmrsObjectArrayCallback)>>(
      'SickScanApiRegisterLdmrsObjectArrayMsg');
  late final _SickScanApiRegisterLdmrsObjectArrayMsg =
      _SickScanApiRegisterLdmrsObjectArrayMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanLdmrsObjectArrayCallback)>();

  int SickScanApiDeregisterLdmrsObjectArrayMsg(
    SickScanApiHandle apiHandle,
    SickScanLdmrsObjectArrayCallback callback,
  ) {
    return _SickScanApiDeregisterLdmrsObjectArrayMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterLdmrsObjectArrayMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanLdmrsObjectArrayCallback)>>(
      'SickScanApiDeregisterLdmrsObjectArrayMsg');
  late final _SickScanApiDeregisterLdmrsObjectArrayMsg =
      _SickScanApiDeregisterLdmrsObjectArrayMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanLdmrsObjectArrayCallback)>();

  /// Register / deregister a callback for VisualizationMarker messages
  int SickScanApiRegisterVisualizationMarkerMsg(
    SickScanApiHandle apiHandle,
    SickScanVisualizationMarkerCallback callback,
  ) {
    return _SickScanApiRegisterVisualizationMarkerMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterVisualizationMarkerMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanVisualizationMarkerCallback)>>(
      'SickScanApiRegisterVisualizationMarkerMsg');
  late final _SickScanApiRegisterVisualizationMarkerMsg =
      _SickScanApiRegisterVisualizationMarkerMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, SickScanVisualizationMarkerCallback)>();

  int SickScanApiDeregisterVisualizationMarkerMsg(
    SickScanApiHandle apiHandle,
    SickScanVisualizationMarkerCallback callback,
  ) {
    return _SickScanApiDeregisterVisualizationMarkerMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterVisualizationMarkerMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanVisualizationMarkerCallback)>>(
      'SickScanApiDeregisterVisualizationMarkerMsg');
  late final _SickScanApiDeregisterVisualizationMarkerMsg =
      _SickScanApiDeregisterVisualizationMarkerMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, SickScanVisualizationMarkerCallback)>();

  /// Register / deregister a callback for SickScanNavPoseLandmark messages
  int SickScanApiRegisterNavPoseLandmarkMsg(
    SickScanApiHandle apiHandle,
    SickScanNavPoseLandmarkCallback callback,
  ) {
    return _SickScanApiRegisterNavPoseLandmarkMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterNavPoseLandmarkMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanNavPoseLandmarkCallback)>>(
      'SickScanApiRegisterNavPoseLandmarkMsg');
  late final _SickScanApiRegisterNavPoseLandmarkMsg =
      _SickScanApiRegisterNavPoseLandmarkMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanNavPoseLandmarkCallback)>();

  int SickScanApiDeregisterNavPoseLandmarkMsg(
    SickScanApiHandle apiHandle,
    SickScanNavPoseLandmarkCallback callback,
  ) {
    return _SickScanApiDeregisterNavPoseLandmarkMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterNavPoseLandmarkMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanNavPoseLandmarkCallback)>>(
      'SickScanApiDeregisterNavPoseLandmarkMsg');
  late final _SickScanApiDeregisterNavPoseLandmarkMsg =
      _SickScanApiDeregisterNavPoseLandmarkMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanNavPoseLandmarkCallback)>();

  /// Register / deregister a callback for diagnostic messages (notification in case of changed status, e.g. after errors)
  int SickScanApiRegisterDiagnosticMsg(
    SickScanApiHandle apiHandle,
    SickScanDiagnosticMsgCallback callback,
  ) {
    return _SickScanApiRegisterDiagnosticMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterDiagnosticMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanDiagnosticMsgCallback)>>(
      'SickScanApiRegisterDiagnosticMsg');
  late final _SickScanApiRegisterDiagnosticMsg =
      _SickScanApiRegisterDiagnosticMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanDiagnosticMsgCallback)>();

  int SickScanApiDeregisterDiagnosticMsg(
    SickScanApiHandle apiHandle,
    SickScanDiagnosticMsgCallback callback,
  ) {
    return _SickScanApiDeregisterDiagnosticMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterDiagnosticMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, SickScanDiagnosticMsgCallback)>>(
      'SickScanApiDeregisterDiagnosticMsg');
  late final _SickScanApiDeregisterDiagnosticMsg =
      _SickScanApiDeregisterDiagnosticMsgPtr.asFunction<
          int Function(SickScanApiHandle, SickScanDiagnosticMsgCallback)>();

  /// Register / deregister a callback for log messages (all informational and error messages)
  int SickScanApiRegisterLogMsg(
    SickScanApiHandle apiHandle,
    SickScanLogMsgCallback callback,
  ) {
    return _SickScanApiRegisterLogMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiRegisterLogMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanLogMsgCallback)>>('SickScanApiRegisterLogMsg');
  late final _SickScanApiRegisterLogMsg = _SickScanApiRegisterLogMsgPtr
      .asFunction<int Function(SickScanApiHandle, SickScanLogMsgCallback)>();

  int SickScanApiDeregisterLogMsg(
    SickScanApiHandle apiHandle,
    SickScanLogMsgCallback callback,
  ) {
    return _SickScanApiDeregisterLogMsg(
      apiHandle,
      callback,
    );
  }

  late final _SickScanApiDeregisterLogMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              SickScanLogMsgCallback)>>('SickScanApiDeregisterLogMsg');
  late final _SickScanApiDeregisterLogMsg = _SickScanApiDeregisterLogMsgPtr
      .asFunction<int Function(SickScanApiHandle, SickScanLogMsgCallback)>();

  /// Query current status and status message
  int SickScanApiGetStatus(
    SickScanApiHandle apiHandle,
    ffi.Pointer<ffi.Int32> status_code,
    ffi.Pointer<ffi.Char> message_buffer,
    int message_buffer_size,
  ) {
    return _SickScanApiGetStatus(
      apiHandle,
      status_code,
      message_buffer,
      message_buffer_size,
    );
  }

  late final _SickScanApiGetStatusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Char>, ffi.Int32)>>('SickScanApiGetStatus');
  late final _SickScanApiGetStatus = _SickScanApiGetStatusPtr.asFunction<
      int Function(SickScanApiHandle, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Sends a SOPAS command like "sRN SCdevicestate" or "sRN ContaminationResult" and returns the lidar response
  int SickScanApiSendSOPAS(
    SickScanApiHandle apiHandle,
    ffi.Pointer<ffi.Char> sopas_command,
    ffi.Pointer<ffi.Char> sopas_response_buffer,
    int response_buffer_size,
  ) {
    return _SickScanApiSendSOPAS(
      apiHandle,
      sopas_command,
      sopas_response_buffer,
      response_buffer_size,
    );
  }

  late final _SickScanApiSendSOPASPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int32)>>('SickScanApiSendSOPAS');
  late final _SickScanApiSendSOPAS = _SickScanApiSendSOPASPtr.asFunction<
      int Function(SickScanApiHandle, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Set verbose level 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=FATAL or 5=QUIET (equivalent to ros::console::levels),
  /// i.e. print messages on console above the given verbose level.
  /// Default verbose level is 1 (INFO), i.e. print informational, warnings and error messages.
  int SickScanApiSetVerboseLevel(
    SickScanApiHandle apiHandle,
    int verbose_level,
  ) {
    return _SickScanApiSetVerboseLevel(
      apiHandle,
      verbose_level,
    );
  }

  late final _SickScanApiSetVerboseLevelPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(SickScanApiHandle, ffi.Int32)>>(
      'SickScanApiSetVerboseLevel');
  late final _SickScanApiSetVerboseLevel = _SickScanApiSetVerboseLevelPtr
      .asFunction<int Function(SickScanApiHandle, int)>();

  /// Returns the current verbose level 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=FATAL or 5=QUIET. Default verbose level is 1 (INFO)
  int SickScanApiGetVerboseLevel(
    SickScanApiHandle apiHandle,
  ) {
    return _SickScanApiGetVerboseLevel(
      apiHandle,
    );
  }

  late final _SickScanApiGetVerboseLevelPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(SickScanApiHandle)>>(
          'SickScanApiGetVerboseLevel');
  late final _SickScanApiGetVerboseLevel = _SickScanApiGetVerboseLevelPtr
      .asFunction<int Function(SickScanApiHandle)>();

  /// Wait for and return the next cartesian resp. polar PointCloud message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextCartesianPointCloudMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanPointCloudMsg> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextCartesianPointCloudMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextCartesianPointCloudMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SickScanApiHandle,
              ffi.Pointer<SickScanPointCloudMsg>,
              ffi.Double)>>('SickScanApiWaitNextCartesianPointCloudMsg');
  late final _SickScanApiWaitNextCartesianPointCloudMsg =
      _SickScanApiWaitNextCartesianPointCloudMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanPointCloudMsg>, double)>();

  int SickScanApiWaitNextPolarPointCloudMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanPointCloudMsg> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextPolarPointCloudMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextPolarPointCloudMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SickScanApiHandle,
              ffi.Pointer<SickScanPointCloudMsg>,
              ffi.Double)>>('SickScanApiWaitNextPolarPointCloudMsg');
  late final _SickScanApiWaitNextPolarPointCloudMsg =
      _SickScanApiWaitNextPolarPointCloudMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanPointCloudMsg>, double)>();

  int SickScanApiFreePointCloudMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanPointCloudMsg> msg,
  ) {
    return _SickScanApiFreePointCloudMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreePointCloudMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, ffi.Pointer<SickScanPointCloudMsg>)>>(
      'SickScanApiFreePointCloudMsg');
  late final _SickScanApiFreePointCloudMsg =
      _SickScanApiFreePointCloudMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanPointCloudMsg>)>();

  /// Wait for and return the next Imu message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextImuMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanImuMsg> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextImuMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextImuMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle, ffi.Pointer<SickScanImuMsg>,
              ffi.Double)>>('SickScanApiWaitNextImuMsg');
  late final _SickScanApiWaitNextImuMsg =
      _SickScanApiWaitNextImuMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanImuMsg>, double)>();

  int SickScanApiFreeImuMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanImuMsg> msg,
  ) {
    return _SickScanApiFreeImuMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreeImuMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              ffi.Pointer<SickScanImuMsg>)>>('SickScanApiFreeImuMsg');
  late final _SickScanApiFreeImuMsg = _SickScanApiFreeImuMsgPtr.asFunction<
      int Function(SickScanApiHandle, ffi.Pointer<SickScanImuMsg>)>();

  /// Wait for and return the next LFErec message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextLFErecMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanLFErecMsg> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextLFErecMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextLFErecMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle, ffi.Pointer<SickScanLFErecMsg>,
              ffi.Double)>>('SickScanApiWaitNextLFErecMsg');
  late final _SickScanApiWaitNextLFErecMsg =
      _SickScanApiWaitNextLFErecMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanLFErecMsg>, double)>();

  int SickScanApiFreeLFErecMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanLFErecMsg> msg,
  ) {
    return _SickScanApiFreeLFErecMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreeLFErecMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              ffi.Pointer<SickScanLFErecMsg>)>>('SickScanApiFreeLFErecMsg');
  late final _SickScanApiFreeLFErecMsg =
      _SickScanApiFreeLFErecMsgPtr.asFunction<
          int Function(SickScanApiHandle, ffi.Pointer<SickScanLFErecMsg>)>();

  /// Wait for and return the next LIDoutputstate message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextLIDoutputstateMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanLIDoutputstateMsg> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextLIDoutputstateMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextLIDoutputstateMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SickScanApiHandle,
              ffi.Pointer<SickScanLIDoutputstateMsg>,
              ffi.Double)>>('SickScanApiWaitNextLIDoutputstateMsg');
  late final _SickScanApiWaitNextLIDoutputstateMsg =
      _SickScanApiWaitNextLIDoutputstateMsgPtr.asFunction<
          int Function(SickScanApiHandle,
              ffi.Pointer<SickScanLIDoutputstateMsg>, double)>();

  int SickScanApiFreeLIDoutputstateMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanLIDoutputstateMsg> msg,
  ) {
    return _SickScanApiFreeLIDoutputstateMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreeLIDoutputstateMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, ffi.Pointer<SickScanLIDoutputstateMsg>)>>(
      'SickScanApiFreeLIDoutputstateMsg');
  late final _SickScanApiFreeLIDoutputstateMsg =
      _SickScanApiFreeLIDoutputstateMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanLIDoutputstateMsg>)>();

  /// Wait for and return the next RadarScan message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextRadarScanMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanRadarScan> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextRadarScanMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextRadarScanMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle, ffi.Pointer<SickScanRadarScan>,
              ffi.Double)>>('SickScanApiWaitNextRadarScanMsg');
  late final _SickScanApiWaitNextRadarScanMsg =
      _SickScanApiWaitNextRadarScanMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanRadarScan>, double)>();

  int SickScanApiFreeRadarScanMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanRadarScan> msg,
  ) {
    return _SickScanApiFreeRadarScanMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreeRadarScanMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(SickScanApiHandle,
              ffi.Pointer<SickScanRadarScan>)>>('SickScanApiFreeRadarScanMsg');
  late final _SickScanApiFreeRadarScanMsg =
      _SickScanApiFreeRadarScanMsgPtr.asFunction<
          int Function(SickScanApiHandle, ffi.Pointer<SickScanRadarScan>)>();

  /// Wait for and return the next LdmrsObjectArray message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextLdmrsObjectArrayMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanLdmrsObjectArray> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextLdmrsObjectArrayMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextLdmrsObjectArrayMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SickScanApiHandle,
              ffi.Pointer<SickScanLdmrsObjectArray>,
              ffi.Double)>>('SickScanApiWaitNextLdmrsObjectArrayMsg');
  late final _SickScanApiWaitNextLdmrsObjectArrayMsg =
      _SickScanApiWaitNextLdmrsObjectArrayMsgPtr.asFunction<
          int Function(SickScanApiHandle, ffi.Pointer<SickScanLdmrsObjectArray>,
              double)>();

  int SickScanApiFreeLdmrsObjectArrayMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanLdmrsObjectArray> msg,
  ) {
    return _SickScanApiFreeLdmrsObjectArrayMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreeLdmrsObjectArrayMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, ffi.Pointer<SickScanLdmrsObjectArray>)>>(
      'SickScanApiFreeLdmrsObjectArrayMsg');
  late final _SickScanApiFreeLdmrsObjectArrayMsg =
      _SickScanApiFreeLdmrsObjectArrayMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanLdmrsObjectArray>)>();

  /// Wait for and return the next VisualizationMarker message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextVisualizationMarkerMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanVisualizationMarkerMsg> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextVisualizationMarkerMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextVisualizationMarkerMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SickScanApiHandle,
              ffi.Pointer<SickScanVisualizationMarkerMsg>,
              ffi.Double)>>('SickScanApiWaitNextVisualizationMarkerMsg');
  late final _SickScanApiWaitNextVisualizationMarkerMsg =
      _SickScanApiWaitNextVisualizationMarkerMsgPtr.asFunction<
          int Function(SickScanApiHandle,
              ffi.Pointer<SickScanVisualizationMarkerMsg>, double)>();

  int SickScanApiFreeVisualizationMarkerMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanVisualizationMarkerMsg> msg,
  ) {
    return _SickScanApiFreeVisualizationMarkerMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreeVisualizationMarkerMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(SickScanApiHandle,
                  ffi.Pointer<SickScanVisualizationMarkerMsg>)>>(
      'SickScanApiFreeVisualizationMarkerMsg');
  late final _SickScanApiFreeVisualizationMarkerMsg =
      _SickScanApiFreeVisualizationMarkerMsgPtr.asFunction<
          int Function(SickScanApiHandle,
              ffi.Pointer<SickScanVisualizationMarkerMsg>)>();

  /// Wait for and return the next SickScanNavPoseLandmark message. Note: SickScanApiWait...Msg() allocates a message. Use function SickScanApiFree...Msg() to deallocate it after use.
  int SickScanApiWaitNextNavPoseLandmarkMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanNavPoseLandmarkMsg> msg,
    double timeout_sec,
  ) {
    return _SickScanApiWaitNextNavPoseLandmarkMsg(
      apiHandle,
      msg,
      timeout_sec,
    );
  }

  late final _SickScanApiWaitNextNavPoseLandmarkMsgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              SickScanApiHandle,
              ffi.Pointer<SickScanNavPoseLandmarkMsg>,
              ffi.Double)>>('SickScanApiWaitNextNavPoseLandmarkMsg');
  late final _SickScanApiWaitNextNavPoseLandmarkMsg =
      _SickScanApiWaitNextNavPoseLandmarkMsgPtr.asFunction<
          int Function(SickScanApiHandle,
              ffi.Pointer<SickScanNavPoseLandmarkMsg>, double)>();

  int SickScanApiFreeNavPoseLandmarkMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanNavPoseLandmarkMsg> msg,
  ) {
    return _SickScanApiFreeNavPoseLandmarkMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiFreeNavPoseLandmarkMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, ffi.Pointer<SickScanNavPoseLandmarkMsg>)>>(
      'SickScanApiFreeNavPoseLandmarkMsg');
  late final _SickScanApiFreeNavPoseLandmarkMsg =
      _SickScanApiFreeNavPoseLandmarkMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanNavPoseLandmarkMsg>)>();

  /// Send odometry data to NAV350
  int SickScanApiNavOdomVelocityMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanNavOdomVelocityMsg> msg,
  ) {
    return _SickScanApiNavOdomVelocityMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiNavOdomVelocityMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, ffi.Pointer<SickScanNavOdomVelocityMsg>)>>(
      'SickScanApiNavOdomVelocityMsg');
  late final _SickScanApiNavOdomVelocityMsg =
      _SickScanApiNavOdomVelocityMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanNavOdomVelocityMsg>)>();

  int SickScanApiOdomVelocityMsg(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanOdomVelocityMsg> msg,
  ) {
    return _SickScanApiOdomVelocityMsg(
      apiHandle,
      msg,
    );
  }

  late final _SickScanApiOdomVelocityMsgPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  SickScanApiHandle, ffi.Pointer<SickScanOdomVelocityMsg>)>>(
      'SickScanApiOdomVelocityMsg');
  late final _SickScanApiOdomVelocityMsg =
      _SickScanApiOdomVelocityMsgPtr.asFunction<
          int Function(
              SickScanApiHandle, ffi.Pointer<SickScanOdomVelocityMsg>)>();

  void init() {
    return _init();
  }

  late final _initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('init');
  late final _init = _initPtr.asFunction<void Function()>();

  void dispose() {
    return _dispose();
  }

  late final _disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('dispose');
  late final _dispose = _disposePtr.asFunction<void Function()>();

  void updateLatestImage(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanPointCloudMsg> pointCloudMsg,
  ) {
    return _updateLatestImage(
      apiHandle,
      pointCloudMsg,
    );
  }

  late final _updateLatestImagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(SickScanApiHandle,
              ffi.Pointer<SickScanPointCloudMsg>)>>('updateLatestImage');
  late final _updateLatestImage = _updateLatestImagePtr.asFunction<
      void Function(SickScanApiHandle, ffi.Pointer<SickScanPointCloudMsg>)>();

  Image getLatestImage() {
    return _getLatestImage();
  }

  late final _getLatestImagePtr =
      _lookup<ffi.NativeFunction<Image Function()>>('getLatestImage');
  late final _getLatestImage =
      _getLatestImagePtr.asFunction<Image Function()>();

  void addHiddenArea() {
    return _addHiddenArea();
  }

  late final _addHiddenAreaPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('addHiddenArea');
  late final _addHiddenArea = _addHiddenAreaPtr.asFunction<void Function()>();

  void addCross(
    ffi.Pointer<SickScanPointCloudMsg> pixels,
  ) {
    return _addCross(
      pixels,
    );
  }

  late final _addCrossPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<SickScanPointCloudMsg>)>>('addCross');
  late final _addCross = _addCrossPtr
      .asFunction<void Function(ffi.Pointer<SickScanPointCloudMsg>)>();

  void make_matrix(
    ffi.Pointer<SickScanPointCloudMsg> imageData,
  ) {
    return _make_matrix(
      imageData,
    );
  }

  late final _make_matrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SickScanPointCloudMsg>)>>('make_matrix');
  late final _make_matrix = _make_matrixPtr
      .asFunction<void Function(ffi.Pointer<SickScanPointCloudMsg>)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final LidarBindings _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  SickScanApiHandle, ffi.Pointer<SickScanPointCloudMsg>)>>
      get updateLatestImage => _library._updateLatestImagePtr;
}

/// Message definitions
final class SickScanHeaderType extends ffi.Struct {
  /// sequence ID: consecutively increasing ID
  @ffi.Uint32()
  external int seq;

  /// seconds part of message timestamps: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
  @ffi.Uint32()
  external int timestamp_sec;

  /// nanoseconds part of message timestamps: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
  @ffi.Uint32()
  external int timestamp_nsec;

  /// Frame this data is associated with
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> frame_id;
}

final class SickScanUint8ArrayType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(uint8_t)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<ffi.Uint8> buffer;
}

abstract class SickScanNativeDataType {
  static const int SICK_SCAN_POINTFIELD_DATATYPE_INT8 = 1;
  static const int SICK_SCAN_POINTFIELD_DATATYPE_UINT8 = 2;
  static const int SICK_SCAN_POINTFIELD_DATATYPE_INT16 = 3;
  static const int SICK_SCAN_POINTFIELD_DATATYPE_UINT16 = 4;
  static const int SICK_SCAN_POINTFIELD_DATATYPE_INT32 = 5;
  static const int SICK_SCAN_POINTFIELD_DATATYPE_UINT32 = 6;
  static const int SICK_SCAN_POINTFIELD_DATATYPE_FLOAT32 = 7;
  static const int SICK_SCAN_POINTFIELD_DATATYPE_FLOAT64 = 8;
}

final class SickScanPointFieldMsgType extends ffi.Struct {
  /// Name of field (max. length 256 characters)
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> name;

  /// Offset from start of point struct
  @ffi.Uint32()
  external int offset;

  /// Datatype enumeration, see SickScanNativeDataType above
  @ffi.Uint8()
  external int datatype;

  /// How many elements in the field
  @ffi.Uint32()
  external int count;
}

final class SickScanPointFieldArrayType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(SickScanPointFieldMsg)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order and system endianess (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<SickScanPointFieldMsg> buffer;
}

typedef SickScanPointFieldMsg = SickScanPointFieldMsgType;

final class SickScanPointCloudMsgType extends ffi.Struct {
  /// message timestamp
  external SickScanHeader header;

  /// 2D structure of the point cloud. If the cloud is unordered, height is 1
  @ffi.Uint32()
  external int height;

  /// and width is the length of the point cloud.
  @ffi.Uint32()
  external int width;

  /// Describes the channels and their layout in the binary data blob.
  external SickScanPointFieldArray fields;

  /// Is this data bigendian?
  @ffi.Uint8()
  external int is_bigendian;

  /// Length of a point in bytes
  @ffi.Uint32()
  external int point_step;

  /// Length of a row in bytes
  @ffi.Uint32()
  external int row_step;

  /// Actual point data, size is (row_step*height)
  external SickScanUint8Array data;

  /// True if there are no invalid points
  @ffi.Uint8()
  external int is_dense;

  /// number of echos
  @ffi.Int32()
  external int num_echos;

  /// segment index (or -1 if pointcloud contains data from multiple segments)
  @ffi.Int32()
  external int segment_idx;

  /// ros topic this pointcloud is published
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> topic;
}

/// Message definitions
typedef SickScanHeader = SickScanHeaderType;
typedef SickScanPointFieldArray = SickScanPointFieldArrayType;
typedef SickScanUint8Array = SickScanUint8ArrayType;

final class SickScanVector3MsgType extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;
}

final class SickScanQuaternionMsgType extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;

  @ffi.Double()
  external double z;

  @ffi.Double()
  external double w;
}

final class SickScanPointArrayType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(SickScanVector3Msg)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order and system endianess (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<SickScanVector3Msg> buffer;
}

typedef SickScanVector3Msg = SickScanVector3MsgType;

final class SickScanImuMsgType extends ffi.Struct {
  /// message timestamp
  external SickScanHeader header;

  external SickScanQuaternionMsg orientation;

  /// Row major about x, y, z axes
  @ffi.Array.multi([9])
  external ffi.Array<ffi.Double> orientation_covariance;

  external SickScanVector3Msg angular_velocity;

  /// Row major about x, y, z axes
  @ffi.Array.multi([9])
  external ffi.Array<ffi.Double> angular_velocity_covariance;

  external SickScanVector3Msg linear_acceleration;

  /// Row major x, y z
  @ffi.Array.multi([9])
  external ffi.Array<ffi.Double> linear_acceleration_covariance;
}

typedef SickScanQuaternionMsg = SickScanQuaternionMsgType;

final class SickScanLFErecFieldMsgType extends ffi.Struct {
  @ffi.Uint16()
  external int version_number;

  @ffi.Uint8()
  external int field_index;

  @ffi.Uint32()
  external int sys_count;

  @ffi.Float()
  external double dist_scale_factor;

  @ffi.Float()
  external double dist_scale_offset;

  @ffi.Uint32()
  external int angle_scale_factor;

  @ffi.Int32()
  external int angle_scale_offset;

  /// field result is 0 (invalid/incorrect), 1 (free/clear) or 2 (infringed)
  @ffi.Uint8()
  external int field_result_mrs;

  /// No time data: 0, Time data: 1
  @ffi.Uint16()
  external int time_state;

  /// f.e. 2021
  @ffi.Uint16()
  external int year;

  /// 1 ... 12
  @ffi.Uint8()
  external int month;

  /// 1 ... 31
  @ffi.Uint8()
  external int day;

  /// 0 ... 23
  @ffi.Uint8()
  external int hour;

  /// 0 ... 59
  @ffi.Uint8()
  external int minute;

  /// 0 ... 59
  @ffi.Uint8()
  external int second;

  /// 0 ... 999999
  @ffi.Uint32()
  external int microsecond;
}

final class SickScanLFErecMsgType extends ffi.Struct {
  /// message timestamp
  external SickScanHeader header;

  /// number of valid fields
  @ffi.Uint16()
  external int fields_number;

  /// max. 3 valid fields
  @ffi.Array.multi([3])
  external ffi.Array<SickScanLFErecFieldMsg> fields;
}

typedef SickScanLFErecFieldMsg = SickScanLFErecFieldMsgType;

final class SickScanLIDoutputstateMsgType extends ffi.Struct {
  /// message timestamp
  external SickScanHeader header;

  /// Status code version number
  @ffi.Uint16()
  external int version_number;

  /// Status code system counter (time in microsec since power up, max. 71 min then starting from 0 again)
  @ffi.Uint32()
  external int system_counter;

  /// array of max. 8 output states, each state with value 0 (not active), 1 (active) or 2 (not used)
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint8> output_state;

  /// array of max. 8 output counter
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint32> output_count;

  /// No time data: 0, Time data: 1 (sensortime from the last change of min. one of the outputs)
  @ffi.Uint16()
  external int time_state;

  /// f.e. 2021
  @ffi.Uint16()
  external int year;

  /// 1 ... 12
  @ffi.Uint8()
  external int month;

  /// 1 ... 31
  @ffi.Uint8()
  external int day;

  /// 0 ... 23
  @ffi.Uint8()
  external int hour;

  /// 0 ... 59
  @ffi.Uint8()
  external int minute;

  /// 0 ... 59
  @ffi.Uint8()
  external int second;

  /// 0 ... 999999
  @ffi.Uint32()
  external int microsecond;
}

final class SickScanRadarPreHeaderType extends ffi.Struct {
  /// version number
  @ffi.Uint16()
  external int uiversionno;

  /// Logical number of the device"
  @ffi.Uint32()
  external int uiident;

  /// Serial number of the device
  @ffi.Uint32()
  external int udiserialno;

  /// State of the device
  @ffi.Uint8()
  external int bdeviceerror;

  /// Contamination Warning
  @ffi.Uint8()
  external int bcontaminationwarning;

  /// Contamination Error
  @ffi.Uint8()
  external int bcontaminationerror;

  /// telegram number
  @ffi.Uint32()
  external int uitelegramcount;

  /// "scan number"
  @ffi.Uint32()
  external int uicyclecount;

  /// system time since power on of scan gen. [us]
  @ffi.Uint32()
  external int udisystemcountscan;

  /// system time since power on of scan transmission [us]
  @ffi.Uint32()
  external int udisystemcounttransmit;

  /// state of digital inputs
  @ffi.Uint16()
  external int uiinputs;

  /// state of digital outputs
  @ffi.Uint16()
  external int uioutputs;

  /// Time in microseconds to detect this items
  @ffi.Uint32()
  external int uicycleduration;

  /// [1/100dB]
  @ffi.Uint32()
  external int uinoiselevel;

  /// number of valid encoders (0)
  @ffi.Uint16()
  external int numencoder;

  /// array of max. 3 encoder position [inc]
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> udiencoderpos;

  /// array of max. 3 encoder speed [inc/mm]
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Int16> iencoderspeed;
}

final class SickScanRadarObjectType extends ffi.Struct {
  @ffi.Int32()
  external int id;

  /// seconds part of tracking_time (since when the object is tracked): seconds (stamp_secs) since epoch
  @ffi.Uint32()
  external int tracking_time_sec;

  /// nanoseconds part of tracking_time (since when the object is tracked): nanoseconds since stamp_secs
  @ffi.Uint32()
  external int tracking_time_nsec;

  /// seconds part of last_seen timestamp: seconds (stamp_secs) since epoch
  @ffi.Uint32()
  external int last_seen_sec;

  /// nanoseconds part of last_seen timestamp: nanoseconds since stamp_secs
  @ffi.Uint32()
  external int last_seen_nsec;

  /// geometry_msgs/TwistWithCovariance velocity
  external SickScanVector3Msg velocity_linear;

  external SickScanVector3Msg velocity_angular;

  /// Row-major representation of the 6x6 covariance matrix (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
  @ffi.Array.multi([36])
  external ffi.Array<ffi.Double> velocity_covariance;

  /// geometry_msgs/Pose bounding_box_center
  external SickScanVector3Msg bounding_box_center_position;

  external SickScanQuaternionMsg bounding_box_center_orientation;

  /// geometry_msgs/Vector3 bounding_box_size
  external SickScanVector3Msg bounding_box_size;

  /// geometry_msgs/PoseWithCovariance object_box_center
  external SickScanVector3Msg object_box_center_position;

  external SickScanQuaternionMsg object_box_center_orientation;

  /// Row-major representation of the 6x6 covariance matrix (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
  @ffi.Array.multi([36])
  external ffi.Array<ffi.Double> object_box_center_covariance;

  /// geometry_msgs/Vector3 object_box_size
  external SickScanVector3Msg object_box_size;

  /// geometry_msgs/Point[] contour_points
  external SickScanPointArray contour_points;
}

typedef SickScanPointArray = SickScanPointArrayType;

final class SickScanRadarObjectArrayType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(SickScanRadarObject)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order and system endianess (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<SickScanRadarObject> buffer;
}

typedef SickScanRadarObject = SickScanRadarObjectType;

final class SickScanRadarScanType extends ffi.Struct {
  /// message timestamp
  external SickScanHeader header;

  /// RadarPreHeader.msg
  external SickScanRadarPreHeader radarpreheader;

  /// sensor_msgs/PointCloud2
  external SickScanPointCloudMsg targets;

  /// Array of RadarObject.msg
  external SickScanRadarObjectArray objects;
}

typedef SickScanRadarPreHeader = SickScanRadarPreHeaderType;
typedef SickScanPointCloudMsg = SickScanPointCloudMsgType;
typedef SickScanRadarObjectArray = SickScanRadarObjectArrayType;

final class SickScanLdmrsObjectBufferType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(SickScanLdmrsObject)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order and system endianess (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<SickScanLdmrsObject> buffer;
}

typedef SickScanLdmrsObject = SickScanRadarObject;

final class SickScanLdmrsObjectArrayType extends ffi.Struct {
  /// message timestamp
  external SickScanHeader header;

  /// Array of SickScanLdmrsObjects
  external SickScanLdmrsObjectBuffer objects;
}

typedef SickScanLdmrsObjectBuffer = SickScanLdmrsObjectBufferType;

final class SickScanColorRGBAType extends ffi.Struct {
  @ffi.Float()
  external double r;

  @ffi.Float()
  external double g;

  @ffi.Float()
  external double b;

  @ffi.Float()
  external double a;
}

final class SickScanColorRGBAArrayType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(SickScanColorRGBA)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order and system endianess (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<SickScanColorRGBA> buffer;
}

typedef SickScanColorRGBA = SickScanColorRGBAType;

final class SickScanVisualizationMarkerType extends ffi.Struct {
  /// message timestamp
  external SickScanHeader header;

  /// Namespace to place this object in... used in conjunction with id to create a unique name for the object
  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Char> ns;

  /// object ID useful in conjunction with the namespace for manipulating and deleting the object later
  @ffi.Int32()
  external int id;

  /// Type of object
  @ffi.Int32()
  external int type;

  /// 0 add/modify an object, 1 (deprecated), 2 deletes an object, 3 deletes all objects
  @ffi.Int32()
  external int action;

  /// Pose of the object (positional part)
  external SickScanVector3Msg pose_position;

  /// Pose of the object (rotational part)
  external SickScanQuaternionMsg pose_orientation;

  /// Scale of the object 1,1,1 means default (usually 1 meter square)
  external SickScanVector3Msg scale;

  /// Color [0.0-1.0]
  external SickScanColorRGBA color;

  /// How long the object should last before being automatically deleted.  0 means forever (seconds part)
  @ffi.Uint32()
  external int lifetime_sec;

  /// How long the object should last before being automatically deleted.  0 means forever (nanoseconds part)
  @ffi.Uint32()
  external int lifetime_nsec;

  /// boolean, If this marker should be frame-locked, i.e. retransformed into its frame every timestep
  @ffi.Uint8()
  external int frame_locked;

  /// Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)
  external SickScanPointArray points;

  /// Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...). Number of colors must either be 0 or equal to the number of points. NOTE: alpha is not yet used
  external SickScanColorRGBAArray colors;

  /// NOTE: only used for text markers
  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Char> text;

  /// NOTE: only used for MESH_RESOURCE markers
  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Char> mesh_resource;

  /// boolean
  @ffi.Uint8()
  external int mesh_use_embedded_materials;
}

typedef SickScanColorRGBAArray = SickScanColorRGBAArrayType;

final class SickScanVisualizationMarkerBufferType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(SickScanVisualizationMarker)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order and system endianess (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<SickScanVisualizationMarker> buffer;
}

typedef SickScanVisualizationMarker = SickScanVisualizationMarkerType;

final class SickScanVisualizationMarkerMsgType extends ffi.Struct {
  /// Array of SickScanVisualizationMarkers
  external SickScanVisualizationMarkerBuffer markers;
}

typedef SickScanVisualizationMarkerBuffer
    = SickScanVisualizationMarkerBufferType;

final class SickScanNavReflectorType extends ffi.Struct {
  @ffi.Uint16()
  external int pos_valid;

  /// reflector x-position in m, if pos_valid > 0
  @ffi.Float()
  external double pos_x;

  /// reflector y-position in m, if pos_valid > 0
  @ffi.Float()
  external double pos_y;

  @ffi.Uint16()
  external int cartesian_valid;

  /// cartesian x in mm, if cartesian_valid > 0
  @ffi.Int32()
  external int cartesian_x;

  /// cartesian y in mm, if cartesian_valid > 0
  @ffi.Int32()
  external int cartesian_y;

  @ffi.Uint16()
  external int polar_valid;

  /// polar dist in mm, if polar_valid > 0
  @ffi.Uint32()
  external int polar_dist;

  /// polar phi in mdeg, if polar_valid > 0
  @ffi.Uint32()
  external int polar_phi;

  @ffi.Uint16()
  external int opt_valid;

  /// Optional reflector data, if opt_valid > 0
  @ffi.Uint16()
  external int opt_local_id;

  @ffi.Uint16()
  external int opt_global_id;

  @ffi.Uint8()
  external int opt_type;

  @ffi.Uint16()
  external int opt_subtype;

  @ffi.Uint16()
  external int opt_quality;

  /// lidar timestamp in milliseconds
  @ffi.Uint32()
  external int opt_timestamp;

  @ffi.Uint16()
  external int opt_size;

  @ffi.Uint16()
  external int opt_hitcount;

  @ffi.Uint16()
  external int opt_meanecho;

  @ffi.Uint16()
  external int opt_startindex;

  @ffi.Uint16()
  external int opt_endindex;

  /// timestamp converted to system time (seconds part, 0 if timestamp not valid)
  @ffi.Uint32()
  external int opt_timestamp_sec;

  /// timestamp converted to system time (nanoseconds part, 0 if timestamp not valid)
  @ffi.Uint32()
  external int opt_timestamp_nsec;
}

final class SickScanNavReflectorBufferType extends ffi.Struct {
  /// Number of allocated elements, i.e. max. number of elements in buffer, allocated buffer size is capacity * sizeof(SickScanNavReflector)
  @ffi.Uint64()
  external int capacity;

  /// Number of currently used elements in the buffer
  @ffi.Uint64()
  external int size;

  /// Memory, data in plain order and system endianess (buffer == 0, if size == 0 && capacity == 0, otherwise allocated memory), allocation/deallocation always managed by the caller.
  external ffi.Pointer<SickScanNavReflector> buffer;
}

typedef SickScanNavReflector = SickScanNavReflectorType;

final class SickScanNavPoseLandmarkMsgType extends ffi.Struct {
  @ffi.Uint16()
  external int pose_valid;

  /// x-position in ros coordinates in m
  @ffi.Float()
  external double pose_x;

  /// y-position in ros coordinates in m
  @ffi.Float()
  external double pose_y;

  /// yaw angle in ros coordinates in radians
  @ffi.Float()
  external double pose_yaw;

  /// timestamp of pose converted to system time (seconds part, 0 if timestamp not valid)
  @ffi.Uint32()
  external int pose_timestamp_sec;

  /// timestamp of pose converted to system time (nanoseconds part, 0 if timestamp not valid)
  @ffi.Uint32()
  external int pose_timestamp_nsec;

  /// x-position in lidar coordinates in mm
  @ffi.Int32()
  external int pose_nav_x;

  /// y-position in lidar coordinates in mm
  @ffi.Int32()
  external int pose_nav_y;

  /// orientation in lidar coordinates in 0 ... 360000 mdeg
  @ffi.Uint32()
  external int pose_nav_phi;

  @ffi.Uint16()
  external int pose_opt_valid;

  /// Optional NAV pose data, if pose_opt_valid > 0:
  @ffi.Uint8()
  external int pose_opt_output_mode;

  /// lidar timestamp in milliseconds
  @ffi.Uint32()
  external int pose_opt_timestamp;

  @ffi.Int32()
  external int pose_opt_mean_dev;

  @ffi.Uint8()
  external int pose_opt_nav_mode;

  @ffi.Uint32()
  external int pose_opt_info_state;

  @ffi.Uint8()
  external int pose_opt_quant_used_reflectors;

  /// Array of SickScanNavReflectors
  external SickScanNavReflectorBuffer reflectors;
}

typedef SickScanNavReflectorBuffer = SickScanNavReflectorBufferType;

final class SickScanNavOdomVelocityMsgType extends ffi.Struct {
  /// x-component of velocity in the coordinate system defined by coordbase (i.e. in lidar coordinate for coordbase=0) in m/s, -32.0 ... +32.0 m/s
  @ffi.Float()
  external double vel_x;

  /// y-component of velocity in the coordinate system defined by coordbase (i.e. in lidar coordinate for coordbase=0) in m/s, -32.0 ... +32.0 m/s
  @ffi.Float()
  external double vel_y;

  /// angular velocity of the NAV350 in radians/s, -2*PI ... +2*PI rad/s
  @ffi.Float()
  external double omega;

  /// timestamp of the Velocity vector related to the NAV350 clock
  @ffi.Uint32()
  external int timestamp;

  /// coordinate system of the velocity vector (local or global), 0 = local coordinate system of the NAV350, 1 = absolute coordinate system
  @ffi.Uint8()
  external int coordbase;
}

final class SickScanOdomVelocityMsgType extends ffi.Struct {
  /// x-component of velocity in ros coordinates in m/s
  @ffi.Float()
  external double vel_x;

  /// y-component of velocity in ros coordinates in m/s
  @ffi.Float()
  external double vel_y;

  /// angular velocity in radians/s
  @ffi.Float()
  external double omega;

  /// seconds part of system timestamp of the odometry data
  @ffi.Uint32()
  external int timestamp_sec;

  /// nanoseconds part of system timestamp of the odometry data
  @ffi.Uint32()
  external int timestamp_nsec;
}

final class SickScanLogMsgType extends ffi.Struct {
  /// log_level defined in ros::console::levels: Info=1, Warn=2, Error=3, Fatal=4
  @ffi.Int32()
  external int log_level;

  /// log message
  external ffi.Pointer<ffi.Char> log_message;
}

final class SickScanDiagnosticMsgType extends ffi.Struct {
  /// status_code defined in SICK_DIAGNOSTIC_STATUS: OK=0 (normal operation), WARN=1 (warning), ERROR=2 (error, should not occure), INIT=3 (initialization after startup or reconnection), EXIT=4 (sick_scan_xd exiting)
  @ffi.Int32()
  external int status_code;

  /// diagnostic message
  external ffi.Pointer<ffi.Char> status_message;
}

/// Callback declarations
typedef SickScanApiHandle = ffi.Pointer<ffi.Void>;
typedef SickScanPointCloudMsgCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanPointCloudMsgCallbackFunction>>;
typedef SickScanPointCloudMsgCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanPointCloudMsg> msg);
typedef DartSickScanPointCloudMsgCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanPointCloudMsg> msg);
typedef SickScanImuMsgCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanImuMsgCallbackFunction>>;
typedef SickScanImuMsgCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanImuMsg> msg);
typedef DartSickScanImuMsgCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanImuMsg> msg);
typedef SickScanImuMsg = SickScanImuMsgType;
typedef SickScanLFErecMsgCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanLFErecMsgCallbackFunction>>;
typedef SickScanLFErecMsgCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLFErecMsg> msg);
typedef DartSickScanLFErecMsgCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLFErecMsg> msg);
typedef SickScanLFErecMsg = SickScanLFErecMsgType;
typedef SickScanLIDoutputstateMsgCallback = ffi
    .Pointer<ffi.NativeFunction<SickScanLIDoutputstateMsgCallbackFunction>>;
typedef SickScanLIDoutputstateMsgCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLIDoutputstateMsg> msg);
typedef DartSickScanLIDoutputstateMsgCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLIDoutputstateMsg> msg);
typedef SickScanLIDoutputstateMsg = SickScanLIDoutputstateMsgType;
typedef SickScanRadarScanCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanRadarScanCallbackFunction>>;
typedef SickScanRadarScanCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanRadarScan> msg);
typedef DartSickScanRadarScanCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanRadarScan> msg);
typedef SickScanRadarScan = SickScanRadarScanType;
typedef SickScanLdmrsObjectArrayCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanLdmrsObjectArrayCallbackFunction>>;
typedef SickScanLdmrsObjectArrayCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLdmrsObjectArray> msg);
typedef DartSickScanLdmrsObjectArrayCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLdmrsObjectArray> msg);
typedef SickScanLdmrsObjectArray = SickScanLdmrsObjectArrayType;
typedef SickScanVisualizationMarkerCallback = ffi
    .Pointer<ffi.NativeFunction<SickScanVisualizationMarkerCallbackFunction>>;
typedef SickScanVisualizationMarkerCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanVisualizationMarkerMsg> msg);
typedef DartSickScanVisualizationMarkerCallbackFunction = void Function(
    SickScanApiHandle apiHandle,
    ffi.Pointer<SickScanVisualizationMarkerMsg> msg);
typedef SickScanVisualizationMarkerMsg = SickScanVisualizationMarkerMsgType;
typedef SickScanNavPoseLandmarkCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanNavPoseLandmarkCallbackFunction>>;
typedef SickScanNavPoseLandmarkCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanNavPoseLandmarkMsg> msg);
typedef DartSickScanNavPoseLandmarkCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanNavPoseLandmarkMsg> msg);
typedef SickScanNavPoseLandmarkMsg = SickScanNavPoseLandmarkMsgType;
typedef SickScanDiagnosticMsgCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanDiagnosticMsgCallbackFunction>>;
typedef SickScanDiagnosticMsgCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanDiagnosticMsg> msg);
typedef DartSickScanDiagnosticMsgCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanDiagnosticMsg> msg);
typedef SickScanDiagnosticMsg = SickScanDiagnosticMsgType;
typedef SickScanLogMsgCallback
    = ffi.Pointer<ffi.NativeFunction<SickScanLogMsgCallbackFunction>>;
typedef SickScanLogMsgCallbackFunction = ffi.Void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLogMsg> msg);
typedef DartSickScanLogMsgCallbackFunction = void Function(
    SickScanApiHandle apiHandle, ffi.Pointer<SickScanLogMsg> msg);
typedef SickScanLogMsg = SickScanLogMsgType;
typedef SickScanNavOdomVelocityMsg = SickScanNavOdomVelocityMsgType;
typedef SickScanOdomVelocityMsg = SickScanOdomVelocityMsgType;

/// Error codes, return values of SickScanApi-functions
abstract class SickScanApiErrorCodes {
  /// function executed successfully
  static const int SICK_SCAN_API_SUCCESS = 0;

  /// general (unspecified) error
  static const int SICK_SCAN_API_ERROR = 1;

  /// sick_scan_xd library not loaded
  static const int SICK_SCAN_API_NOT_LOADED = 2;

  /// API not initialized
  static const int SICK_SCAN_API_NOT_INITIALIZED = 3;

  /// function not implemented in sick_scan_xd library
  static const int SICK_SCAN_API_NOT_IMPLEMENTED = 4;

  /// timeout during wait for response
  static const int SICK_SCAN_API_TIMEOUT = 5;
}

final class Image extends ffi.Struct {
  @ffi.Uint64()
  external int height;

  @ffi.Uint64()
  external int width;

  /// uint64_t capacity;
  /// SickScanUint8Array buffer;
  external ffi.Pointer<ffi.Uint8> data;
}
