// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for the RealSense SDK.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml -v severe`.
///
class LibRealSenseBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibRealSenseBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibRealSenseBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<pkg_ffi.Utf8> rs2_timestamp_domain_to_string(
    int info,
  ) {
    return _rs2_timestamp_domain_to_string(
      info,
    );
  }

  late final _rs2_timestamp_domain_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_timestamp_domain_to_string');
  late final _rs2_timestamp_domain_to_string =
      _rs2_timestamp_domain_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_frame_metadata_to_string(
    int metadata,
  ) {
    return _rs2_frame_metadata_to_string(
      metadata,
    );
  }

  late final _rs2_frame_metadata_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_frame_metadata_to_string');
  late final _rs2_frame_metadata_to_string = _rs2_frame_metadata_to_stringPtr
      .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_frame_metadata_value_to_string(
    int metadata,
  ) {
    return _rs2_frame_metadata_value_to_string(
      metadata,
    );
  }

  late final _rs2_frame_metadata_value_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_frame_metadata_value_to_string');
  late final _rs2_frame_metadata_value_to_string =
      _rs2_frame_metadata_value_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_calib_target_type_to_string(
    int type,
  ) {
    return _rs2_calib_target_type_to_string(
      type,
    );
  }

  late final _rs2_calib_target_type_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_calib_target_type_to_string');
  late final _rs2_calib_target_type_to_string =
      _rs2_calib_target_type_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  /// retrieve metadata from frame handle
  /// \param[in] frame      handle returned from a callback
  /// \param[in] frame_metadata  the rs2_frame_metadata whose latest frame we are interested in
  /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return            the metadata value
  int rs2_get_frame_metadata(
    ffi.Pointer<rs2_frame> frame,
    int frame_metadata,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_metadata(
      frame,
      frame_metadata,
      error,
    );
  }

  late final _rs2_get_frame_metadataPtr = _lookup<
      ffi.NativeFunction<
          rs2_metadata_type Function(ffi.Pointer<rs2_frame>, ffi.Int32,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_metadata');
  late final _rs2_get_frame_metadata = _rs2_get_frame_metadataPtr.asFunction<
      int Function(
          ffi.Pointer<rs2_frame>, int, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// determine device metadata
  /// \param[in] frame             handle returned from a callback
  /// \param[in] frame_metadata    the metadata to check for support
  /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                true if device has this metadata
  int rs2_supports_frame_metadata(
    ffi.Pointer<rs2_frame> frame,
    int frame_metadata,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_supports_frame_metadata(
      frame,
      frame_metadata,
      error,
    );
  }

  late final _rs2_supports_frame_metadataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<rs2_frame>, ffi.Int32,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_supports_frame_metadata');
  late final _rs2_supports_frame_metadata =
      _rs2_supports_frame_metadataPtr.asFunction<
          int Function(ffi.Pointer<rs2_frame>, int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve timestamp domain from frame handle. timestamps can only be comparable if they are in common domain
  /// (for example, depth timestamp might come from system time while color timestamp might come from the device)
  /// this method is used to check if two timestamp values are comparable (generated from the same clock)
  /// \param[in] frameset   handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               the timestamp domain of the frame (camera / microcontroller / system time)
  int rs2_get_frame_timestamp_domain(
    ffi.Pointer<rs2_frame> frameset,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_timestamp_domain(
      frameset,
      error,
    );
  }

  late final _rs2_get_frame_timestamp_domainPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_frame_timestamp_domain');
  late final _rs2_get_frame_timestamp_domain =
      _rs2_get_frame_timestamp_domainPtr.asFunction<
          int Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve timestamp from frame handle in milliseconds
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               the timestamp of the frame in milliseconds
  double rs2_get_frame_timestamp(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_timestamp(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_timestampPtr = _lookup<
      ffi.NativeFunction<
          rs2_time_t Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_timestamp');
  late final _rs2_get_frame_timestamp = _rs2_get_frame_timestampPtr.asFunction<
      double Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve frame parent sensor from frame handle
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               the parent sensor of the frame
  ffi.Pointer<rs2_sensor> rs2_get_frame_sensor(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_sensor(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_sensorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rs2_sensor> Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_sensor');
  late final _rs2_get_frame_sensor = _rs2_get_frame_sensorPtr.asFunction<
      ffi.Pointer<rs2_sensor> Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve frame number from frame handle
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               the frame nubmer of the frame, in milliseconds since the device was started
  int rs2_get_frame_number(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_number(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_numberPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_number');
  late final _rs2_get_frame_number = _rs2_get_frame_numberPtr.asFunction<
      int Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve data size from frame handle
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               the size of the frame data
  int rs2_get_frame_data_size(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_data_size(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_data_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_data_size');
  late final _rs2_get_frame_data_size = _rs2_get_frame_data_sizePtr.asFunction<
      int Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve data from frame handle
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               the pointer to the start of the frame data
  ffi.Pointer<ffi.Void> rs2_get_frame_data(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_data(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_data');
  late final _rs2_get_frame_data = _rs2_get_frame_dataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve frame width in pixels
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               frame width in pixels
  int rs2_get_frame_width(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_width(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_widthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_width');
  late final _rs2_get_frame_width = _rs2_get_frame_widthPtr.asFunction<
      int Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve frame height in pixels
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               frame height in pixels
  int rs2_get_frame_height(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_height(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_heightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_height');
  late final _rs2_get_frame_height = _rs2_get_frame_heightPtr.asFunction<
      int Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve the scaling factor to use when converting a depth frame's get_data() units to meters
  /// \return float - depth, in meters, per 1 unit stored in the frame data
  double rs2_depth_frame_get_units(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_depth_frame_get_units(
      frame,
      error,
    );
  }

  late final _rs2_depth_frame_get_unitsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_depth_frame_get_units');
  late final _rs2_depth_frame_get_units =
      _rs2_depth_frame_get_unitsPtr.asFunction<
          double Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve frame stride in bytes (number of bytes from start of line N to start of line N+1)
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               stride in bytes
  int rs2_get_frame_stride_in_bytes(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_stride_in_bytes(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_stride_in_bytesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_frame_stride_in_bytes');
  late final _rs2_get_frame_stride_in_bytes =
      _rs2_get_frame_stride_in_bytesPtr.asFunction<
          int Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve bits per pixels in the frame image
  /// (note that bits per pixel is not necessarily divided by 8, as in 12bpp)
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               bits per pixel
  int rs2_get_frame_bits_per_pixel(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_bits_per_pixel(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_bits_per_pixelPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_frame_bits_per_pixel');
  late final _rs2_get_frame_bits_per_pixel =
      _rs2_get_frame_bits_per_pixelPtr.asFunction<
          int Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// create additional reference to a frame without duplicating frame data
  /// \param[in] frame      handle returned from a callback
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return               new frame reference, has to be released by rs2_release_frame
  void rs2_frame_add_ref(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_frame_add_ref(
      frame,
      error,
    );
  }

  late final _rs2_frame_add_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_frame_add_ref');
  late final _rs2_frame_add_ref = _rs2_frame_add_refPtr.asFunction<
      void Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// relases the frame handle
  /// \param[in] frame handle returned from a callback
  void rs2_release_frame(
    ffi.Pointer<rs2_frame> frame,
  ) {
    return _rs2_release_frame(
      frame,
    );
  }

  late final _rs2_release_framePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<rs2_frame>)>>(
          'rs2_release_frame');
  late final _rs2_release_frame =
      _rs2_release_framePtr.asFunction<void Function(ffi.Pointer<rs2_frame>)>();

  /// communicate to the library you intend to keep the frame alive for a while
  /// this will remove the frame from the regular count of the frame pool
  /// once this function is called, the SDK can no longer guarantee 0-allocations during frame cycling
  /// \param[in] frame handle returned from a callback
  void rs2_keep_frame(
    ffi.Pointer<rs2_frame> frame,
  ) {
    return _rs2_keep_frame(
      frame,
    );
  }

  late final _rs2_keep_framePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<rs2_frame>)>>(
          'rs2_keep_frame');
  late final _rs2_keep_frame =
      _rs2_keep_framePtr.asFunction<void Function(ffi.Pointer<rs2_frame>)>();

  /// When called on Points frame type, this method returns a pointer to an array of 3D vertices of the model
  /// The coordinate system is: X right, Y up, Z away from the camera. Units: Meters
  /// \param[in] frame       Points frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                Pointer to an array of vertices, lifetime is managed by the frame
  ffi.Pointer<rs2_vertex> rs2_get_frame_vertices(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_vertices(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_verticesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rs2_vertex> Function(ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_frame_vertices');
  late final _rs2_get_frame_vertices = _rs2_get_frame_verticesPtr.asFunction<
      ffi.Pointer<rs2_vertex> Function(
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// When called on Points frame type, this method creates a ply file of the model with the given file name.
  /// \param[in] frame       Points frame
  /// \param[in] fname       The name for the ply file
  /// \param[in] texture     Texture frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_export_to_ply(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<pkg_ffi.Utf8> fname,
    ffi.Pointer<rs2_frame> texture,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_export_to_ply(
      frame,
      fname,
      texture,
      error,
    );
  }

  late final _rs2_export_to_plyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<rs2_frame>,
              ffi.Pointer<pkg_ffi.Utf8>,
              ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_export_to_ply');
  late final _rs2_export_to_ply = _rs2_export_to_plyPtr.asFunction<
      void Function(ffi.Pointer<rs2_frame>, ffi.Pointer<pkg_ffi.Utf8>,
          ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// When called on Points frame type, this method returns a pointer to an array of texture coordinates per vertex
  /// Each coordinate represent a (u,v) pair within [0,1] range, to be mapped to texture image
  /// \param[in] frame       Points frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                Pointer to an array of texture coordinates, lifetime is managed by the frame
  ffi.Pointer<rs2_pixel> rs2_get_frame_texture_coordinates(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_texture_coordinates(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_texture_coordinatesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_pixel> Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_frame_texture_coordinates');
  late final _rs2_get_frame_texture_coordinates =
      _rs2_get_frame_texture_coordinatesPtr.asFunction<
          ffi.Pointer<rs2_pixel> Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// When called on Points frame type, this method returns the number of vertices in the frame
  /// \param[in] frame       Points frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                Number of vertices
  int rs2_get_frame_points_count(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_points_count(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_points_countPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_frame_points_count');
  late final _rs2_get_frame_points_count =
      _rs2_get_frame_points_countPtr.asFunction<
          int Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Returns the stream profile that was used to start the stream of this frame
  /// \param[in] frame       frame reference, owned by the user
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                Pointer to the stream profile object, lifetime is managed elsewhere
  ffi.Pointer<rs2_stream_profile> rs2_get_frame_stream_profile(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_frame_stream_profile(
      frame,
      error,
    );
  }

  late final _rs2_get_frame_stream_profilePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_stream_profile> Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_frame_stream_profile');
  late final _rs2_get_frame_stream_profile =
      _rs2_get_frame_stream_profilePtr.asFunction<
          ffi.Pointer<rs2_stream_profile> Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Test if the given frame can be extended to the requested extension
  /// \param[in]  frame             Realsense frame
  /// \param[in]  extension_type    The extension to which the frame should be tested if it is extendable
  /// \param[out] error             If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return non-zero value iff the frame can be extended to the given extension
  int rs2_is_frame_extendable_to(
    ffi.Pointer<rs2_frame> frame,
    int extension_type,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_is_frame_extendable_to(
      frame,
      extension_type,
      error,
    );
  }

  late final _rs2_is_frame_extendable_toPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<rs2_frame>, ffi.Int32,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_is_frame_extendable_to');
  late final _rs2_is_frame_extendable_to =
      _rs2_is_frame_extendable_toPtr.asFunction<
          int Function(ffi.Pointer<rs2_frame>, int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Allocate new video frame using a frame-source provided form a processing block
  /// \param[in] source      Frame pool to allocate the frame from
  /// \param[in] new_stream  New stream profile to assign to newly created frame
  /// \param[in] original    A reference frame that can be used to fill in auxilary information like format, width, height, bpp, stride (if applicable)
  /// \param[in] new_bpp     New value for bits per pixel for the allocated frame
  /// \param[in] new_width   New value for width for the allocated frame
  /// \param[in] new_height  New value for height for the allocated frame
  /// \param[in] new_stride  New value for stride in bytes for the allocated frame
  /// \param[in] frame_type  New value for frame type for the allocated frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                reference to a newly allocated frame, must be released with release_frame
  /// memory for the frame is likely to be re-used from previous frame, but in lack of available frames in the pool will be allocated from the free store
  ffi.Pointer<rs2_frame> rs2_allocate_synthetic_video_frame(
    ffi.Pointer<rs2_source> source,
    ffi.Pointer<rs2_stream_profile> new_stream,
    ffi.Pointer<rs2_frame> original,
    int new_bpp,
    int new_width,
    int new_height,
    int new_stride,
    int frame_type,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_allocate_synthetic_video_frame(
      source,
      new_stream,
      original,
      new_bpp,
      new_width,
      new_height,
      new_stride,
      frame_type,
      error,
    );
  }

  late final _rs2_allocate_synthetic_video_framePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_frame> Function(
                  ffi.Pointer<rs2_source>,
                  ffi.Pointer<rs2_stream_profile>,
                  ffi.Pointer<rs2_frame>,
                  ffi.Int,
                  ffi.Int,
                  ffi.Int,
                  ffi.Int,
                  ffi.Int32,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_allocate_synthetic_video_frame');
  late final _rs2_allocate_synthetic_video_frame =
      _rs2_allocate_synthetic_video_framePtr.asFunction<
          ffi.Pointer<rs2_frame> Function(
              ffi.Pointer<rs2_source>,
              ffi.Pointer<rs2_stream_profile>,
              ffi.Pointer<rs2_frame>,
              int,
              int,
              int,
              int,
              int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Allocate new motion frame using a frame-source provided form a processing block
  /// \param[in] source      Frame pool to allocate the frame from
  /// \param[in] new_stream  New stream profile to assign to newly created frame
  /// \param[in] original    A reference frame that can be used to fill in auxilary information like format, width, height, bpp, stride (if applicable)
  /// \param[in] frame_type  New value for frame type for the allocated frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                reference to a newly allocated frame, must be released with release_frame
  /// memory for the frame is likely to be re-used from previous frame, but in lack of available frames in the pool will be allocated from the free store
  ffi.Pointer<rs2_frame> rs2_allocate_synthetic_motion_frame(
    ffi.Pointer<rs2_source> source,
    ffi.Pointer<rs2_stream_profile> new_stream,
    ffi.Pointer<rs2_frame> original,
    int frame_type,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_allocate_synthetic_motion_frame(
      source,
      new_stream,
      original,
      frame_type,
      error,
    );
  }

  late final _rs2_allocate_synthetic_motion_framePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_frame> Function(
                  ffi.Pointer<rs2_source>,
                  ffi.Pointer<rs2_stream_profile>,
                  ffi.Pointer<rs2_frame>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_allocate_synthetic_motion_frame');
  late final _rs2_allocate_synthetic_motion_frame =
      _rs2_allocate_synthetic_motion_framePtr.asFunction<
          ffi.Pointer<rs2_frame> Function(
              ffi.Pointer<rs2_source>,
              ffi.Pointer<rs2_stream_profile>,
              ffi.Pointer<rs2_frame>,
              int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Allocate new points frame using a frame-source provided from a processing block
  /// \param[in] source      Frame pool to allocate the frame from
  /// \param[in] new_stream  New stream profile to assign to newly created frame
  /// \param[in] original    A reference frame that can be used to fill in auxilary information like format, width, height, bpp, stride (if applicable)
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                reference to a newly allocated frame, must be released with release_frame
  /// memory for the frame is likely to be re-used from previous frame, but in lack of available frames in the pool will be allocated from the free store
  ffi.Pointer<rs2_frame> rs2_allocate_points(
    ffi.Pointer<rs2_source> source,
    ffi.Pointer<rs2_stream_profile> new_stream,
    ffi.Pointer<rs2_frame> original,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_allocate_points(
      source,
      new_stream,
      original,
      error,
    );
  }

  late final _rs2_allocate_pointsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rs2_frame> Function(
              ffi.Pointer<rs2_source>,
              ffi.Pointer<rs2_stream_profile>,
              ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_allocate_points');
  late final _rs2_allocate_points = _rs2_allocate_pointsPtr.asFunction<
      ffi.Pointer<rs2_frame> Function(
          ffi.Pointer<rs2_source>,
          ffi.Pointer<rs2_stream_profile>,
          ffi.Pointer<rs2_frame>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Allocate new composite frame, aggregating a set of existing frames
  /// \param[in] source      Frame pool to allocate the frame from
  /// \param[in] frames      Array of existing frames
  /// \param[in] count       Number of input frames
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                reference to a newly allocated frame, must be released with release_frame
  /// when composite frame gets released it will automatically release all of the input frames
  ffi.Pointer<rs2_frame> rs2_allocate_composite_frame(
    ffi.Pointer<rs2_source> source,
    ffi.Pointer<ffi.Pointer<rs2_frame>> frames,
    int count,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_allocate_composite_frame(
      source,
      frames,
      count,
      error,
    );
  }

  late final _rs2_allocate_composite_framePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_frame> Function(
                  ffi.Pointer<rs2_source>,
                  ffi.Pointer<ffi.Pointer<rs2_frame>>,
                  ffi.Int,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_allocate_composite_frame');
  late final _rs2_allocate_composite_frame =
      _rs2_allocate_composite_framePtr.asFunction<
          ffi.Pointer<rs2_frame> Function(
              ffi.Pointer<rs2_source>,
              ffi.Pointer<ffi.Pointer<rs2_frame>>,
              int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Extract frame from within a composite frame
  /// \param[in] composite   Composite frame
  /// \param[in] index       Index of the frame to extract within the composite frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                returns reference to a frame existing within the composite frame
  /// If you wish to keep this frame after the composite is released, you need to call acquire_ref
  /// Otherwise the resulting frame lifetime is bound by owning composite frame
  ffi.Pointer<rs2_frame> rs2_extract_frame(
    ffi.Pointer<rs2_frame> composite,
    int index,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_extract_frame(
      composite,
      index,
      error,
    );
  }

  late final _rs2_extract_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rs2_frame> Function(ffi.Pointer<rs2_frame>, ffi.Int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_extract_frame');
  late final _rs2_extract_frame = _rs2_extract_framePtr.asFunction<
      ffi.Pointer<rs2_frame> Function(
          ffi.Pointer<rs2_frame>, int, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Get number of frames embedded within a composite frame
  /// \param[in] composite   Composite input frame
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return                Number of embedded frames
  int rs2_embedded_frames_count(
    ffi.Pointer<rs2_frame> composite,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_embedded_frames_count(
      composite,
      error,
    );
  }

  late final _rs2_embedded_frames_countPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_embedded_frames_count');
  late final _rs2_embedded_frames_count =
      _rs2_embedded_frames_countPtr.asFunction<
          int Function(
              ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// This method will dispatch frame callback on a frame
  /// \param[in] source      Frame pool provided by the processing block
  /// \param[in] frame       Frame to dispatch, frame ownership is passed to this function, so you don't have to call release_frame after it
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_synthetic_frame_ready(
    ffi.Pointer<rs2_source> source,
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_synthetic_frame_ready(
      source,
      frame,
      error,
    );
  }

  late final _rs2_synthetic_frame_readyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<rs2_source>, ffi.Pointer<rs2_frame>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_synthetic_frame_ready');
  late final _rs2_synthetic_frame_ready =
      _rs2_synthetic_frame_readyPtr.asFunction<
          void Function(ffi.Pointer<rs2_source>, ffi.Pointer<rs2_frame>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// When called on Pose frame type, this method returns the transformation represented by the pose data
  /// \param[in] frame       Pose frame
  /// \param[out] pose       Pointer to a user allocated struct, which contains the pose info after a successful return
  /// \param[out] error      If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_pose_frame_get_pose_data(
    ffi.Pointer<rs2_frame> frame,
    ffi.Pointer<rs2_pose> pose,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pose_frame_get_pose_data(
      frame,
      pose,
      error,
    );
  }

  late final _rs2_pose_frame_get_pose_dataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<rs2_frame>, ffi.Pointer<rs2_pose>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pose_frame_get_pose_data');
  late final _rs2_pose_frame_get_pose_data =
      _rs2_pose_frame_get_pose_dataPtr.asFunction<
          void Function(ffi.Pointer<rs2_frame>, ffi.Pointer<rs2_pose>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Extract the target dimensions on the specific target
  /// \param[in] frame            Left or right camera frame of specified size based on the target type
  /// \param[in] calib_type       Calibration target type
  /// \param[in] target_dims_size Target dimension array size. 4 for RS2_CALIB_TARGET_RECT_GAUSSIAN_DOT_VERTICES and 8 for RS2_CALIB_TARGET_POS_GAUSSIAN_DOT_VERTICES.
  /// \param[out] target_dims     The array to hold the result target dimensions calculated.
  /// For type RS2_CALIB_TARGET_RECT_GAUSSIAN_DOT_VERTICES, the four rectangle side sizes in pixels with the order of top, bottom, left, and right
  /// For type RS2_CALIB_TARGET_POS_GAUSSIAN_DOT_VERTICES, the four vertices coordinates in pixels with the order of top, bottom, left, and right
  /// \param[out] error           If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_extract_target_dimensions(
    ffi.Pointer<rs2_frame> frame,
    int calib_type,
    ffi.Pointer<ffi.Float> target_dims,
    int target_dims_size,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_extract_target_dimensions(
      frame,
      calib_type,
      target_dims,
      target_dims_size,
      error,
    );
  }

  late final _rs2_extract_target_dimensionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<rs2_frame>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Float>,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_extract_target_dimensions');
  late final _rs2_extract_target_dimensions =
      _rs2_extract_target_dimensionsPtr.asFunction<
          void Function(ffi.Pointer<rs2_frame>, int, ffi.Pointer<ffi.Float>,
              int, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// This function is being deprecated. For existing options it will return option name, but for future API additions the user should call rs2_get_option_name instead.
  ffi.Pointer<pkg_ffi.Utf8> rs2_option_to_string(
    int option,
  ) {
    return _rs2_option_to_string(
      option,
    );
  }

  late final _rs2_option_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_option_to_string');
  late final _rs2_option_to_string = _rs2_option_to_stringPtr
      .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_sr300_visual_preset_to_string(
    int preset,
  ) {
    return _rs2_sr300_visual_preset_to_string(
      preset,
    );
  }

  late final _rs2_sr300_visual_preset_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_sr300_visual_preset_to_string');
  late final _rs2_sr300_visual_preset_to_string =
      _rs2_sr300_visual_preset_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_rs400_visual_preset_to_string(
    int preset,
  ) {
    return _rs2_rs400_visual_preset_to_string(
      preset,
    );
  }

  late final _rs2_rs400_visual_preset_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_rs400_visual_preset_to_string');
  late final _rs2_rs400_visual_preset_to_string =
      _rs2_rs400_visual_preset_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_l500_visual_preset_to_string(
    int preset,
  ) {
    return _rs2_l500_visual_preset_to_string(
      preset,
    );
  }

  late final _rs2_l500_visual_preset_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_l500_visual_preset_to_string');
  late final _rs2_l500_visual_preset_to_string =
      _rs2_l500_visual_preset_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_sensor_mode_to_string(
    int preset,
  ) {
    return _rs2_sensor_mode_to_string(
      preset,
    );
  }

  late final _rs2_sensor_mode_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_sensor_mode_to_string');
  late final _rs2_sensor_mode_to_string = _rs2_sensor_mode_to_stringPtr
      .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_ambient_light_to_string(
    int preset,
  ) {
    return _rs2_ambient_light_to_string(
      preset,
    );
  }

  late final _rs2_ambient_light_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_ambient_light_to_string');
  late final _rs2_ambient_light_to_string = _rs2_ambient_light_to_stringPtr
      .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_digital_gain_to_string(
    int preset,
  ) {
    return _rs2_digital_gain_to_string(
      preset,
    );
  }

  late final _rs2_digital_gain_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_digital_gain_to_string');
  late final _rs2_digital_gain_to_string = _rs2_digital_gain_to_stringPtr
      .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_host_perf_mode_to_string(
    int perf,
  ) {
    return _rs2_host_perf_mode_to_string(
      perf,
    );
  }

  late final _rs2_host_perf_mode_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_host_perf_mode_to_string');
  late final _rs2_host_perf_mode_to_string = _rs2_host_perf_mode_to_stringPtr
      .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_emitter_frequency_mode_to_string(
    int mode,
  ) {
    return _rs2_emitter_frequency_mode_to_string(
      mode,
    );
  }

  late final _rs2_emitter_frequency_mode_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_emitter_frequency_mode_to_string');
  late final _rs2_emitter_frequency_mode_to_string =
      _rs2_emitter_frequency_mode_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_depth_auto_exposure_mode_to_string(
    int mode,
  ) {
    return _rs2_depth_auto_exposure_mode_to_string(
      mode,
    );
  }

  late final _rs2_depth_auto_exposure_mode_to_stringPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Int32)>>(
      'rs2_depth_auto_exposure_mode_to_string');
  late final _rs2_depth_auto_exposure_mode_to_string =
      _rs2_depth_auto_exposure_mode_to_stringPtr
          .asFunction<ffi.Pointer<pkg_ffi.Utf8> Function(int)>();

  /// check if an option is read-only
  /// \param[in] options  the options container
  /// \param[in] option   option id to be checked
  /// \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return true if option is read-only
  int rs2_is_option_read_only(
    ffi.Pointer<rs2_options> options,
    int option,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_is_option_read_only(
      options,
      option,
      error,
    );
  }

  late final _rs2_is_option_read_onlyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<rs2_options>, ffi.Int32,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_is_option_read_only');
  late final _rs2_is_option_read_only = _rs2_is_option_read_onlyPtr.asFunction<
      int Function(ffi.Pointer<rs2_options>, int,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// read option value from the sensor
  /// \param[in] options  the options container
  /// \param[in] option   option id to be queried
  /// \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return value of the option
  double rs2_get_option(
    ffi.Pointer<rs2_options> options,
    int option,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_option(
      options,
      option,
      error,
    );
  }

  late final _rs2_get_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<rs2_options>, ffi.Int32,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_option');
  late final _rs2_get_option = _rs2_get_optionPtr.asFunction<
      double Function(ffi.Pointer<rs2_options>, int,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// write new value to sensor option
  /// \param[in] options    the options container
  /// \param[in] option     option id to be queried
  /// \param[in] value      new value for the option
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_set_option(
    ffi.Pointer<rs2_options> options,
    int option,
    double value,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_set_option(
      options,
      option,
      value,
      error,
    );
  }

  late final _rs2_set_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<rs2_options>, ffi.Int32, ffi.Float,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_set_option');
  late final _rs2_set_option = _rs2_set_optionPtr.asFunction<
      void Function(ffi.Pointer<rs2_options>, int, double,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// get the list of supported options of options container
  /// \param[in] options    the options container
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  ffi.Pointer<rs2_options_list> rs2_get_options_list(
    ffi.Pointer<rs2_options> options,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_options_list(
      options,
      error,
    );
  }

  late final _rs2_get_options_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rs2_options_list> Function(ffi.Pointer<rs2_options>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_options_list');
  late final _rs2_get_options_list = _rs2_get_options_listPtr.asFunction<
      ffi.Pointer<rs2_options_list> Function(
          ffi.Pointer<rs2_options>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// get the size of options list
  /// \param[in] options    the option list
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  int rs2_get_options_list_size(
    ffi.Pointer<rs2_options_list> options,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_options_list_size(
      options,
      error,
    );
  }

  late final _rs2_get_options_list_sizePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<rs2_options_list>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_options_list_size');
  late final _rs2_get_options_list_size =
      _rs2_get_options_list_sizePtr.asFunction<
          int Function(ffi.Pointer<rs2_options_list>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// get option name
  /// \param[in] options    the options container
  /// \param[in] option     option id to be checked
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return human-readable option name
  ffi.Pointer<pkg_ffi.Utf8> rs2_get_option_name(
    ffi.Pointer<rs2_options> options,
    int option,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_option_name(
      options,
      option,
      error,
    );
  }

  late final _rs2_get_option_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pkg_ffi.Utf8> Function(
              ffi.Pointer<rs2_options>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_option_name');
  late final _rs2_get_option_name = _rs2_get_option_namePtr.asFunction<
      ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_options>, int,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// get the specific option from options list
  /// \param[in] i    the index of the option
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  int rs2_get_option_from_list(
    ffi.Pointer<rs2_options_list> options,
    int i,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_option_from_list(
      options,
      i,
      error,
    );
  }

  late final _rs2_get_option_from_listPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<rs2_options_list>, ffi.Int,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_option_from_list');
  late final _rs2_get_option_from_list =
      _rs2_get_option_from_listPtr.asFunction<
          int Function(ffi.Pointer<rs2_options_list>, int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Deletes options list
  /// \param[in] list list to delete
  void rs2_delete_options_list(
    ffi.Pointer<rs2_options_list> list,
  ) {
    return _rs2_delete_options_list(
      list,
    );
  }

  late final _rs2_delete_options_listPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<rs2_options_list>)>>(
      'rs2_delete_options_list');
  late final _rs2_delete_options_list = _rs2_delete_options_listPtr
      .asFunction<void Function(ffi.Pointer<rs2_options_list>)>();

  /// check if particular option is supported by a subdevice
  /// \param[in] options    the options container
  /// \param[in] option     option id to be checked
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return true if option is supported
  int rs2_supports_option(
    ffi.Pointer<rs2_options> options,
    int option,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_supports_option(
      options,
      option,
      error,
    );
  }

  late final _rs2_supports_optionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<rs2_options>, ffi.Int32,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_supports_option');
  late final _rs2_supports_option = _rs2_supports_optionPtr.asFunction<
      int Function(ffi.Pointer<rs2_options>, int,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// retrieve the available range of values of a supported option
  /// \param[in] sensor  the RealSense device
  /// \param[in] option  the option whose range should be queried
  /// \param[out] min    the minimum value which will be accepted for this option
  /// \param[out] max    the maximum value which will be accepted for this option
  /// \param[out] step   the granularity of options which accept discrete values, or zero if the option accepts continuous values
  /// \param[out] def    the default value of the option
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_get_option_range(
    ffi.Pointer<rs2_options> sensor,
    int option,
    ffi.Pointer<ffi.Float> min,
    ffi.Pointer<ffi.Float> max,
    ffi.Pointer<ffi.Float> step,
    ffi.Pointer<ffi.Float> def,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_option_range(
      sensor,
      option,
      min,
      max,
      step,
      def,
      error,
    );
  }

  late final _rs2_get_option_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<rs2_options>,
              ffi.Int32,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_option_range');
  late final _rs2_get_option_range = _rs2_get_option_rangePtr.asFunction<
      void Function(
          ffi.Pointer<rs2_options>,
          int,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// get option description
  /// \param[in] options    the options container
  /// \param[in] option     option id to be checked
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return human-readable option description
  ffi.Pointer<pkg_ffi.Utf8> rs2_get_option_description(
    ffi.Pointer<rs2_options> options,
    int option,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_option_description(
      options,
      option,
      error,
    );
  }

  late final _rs2_get_option_descriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_options>,
                  ffi.Int32, ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_option_description');
  late final _rs2_get_option_description =
      _rs2_get_option_descriptionPtr.asFunction<
          ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_options>, int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// get option value description (in case specific option value hold special meaning)
  /// \param[in] options    the options container
  /// \param[in] option     option id to be checked
  /// \param[in] value      value of the option
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return human-readable description of a specific value of an option or null if no special meaning
  ffi.Pointer<pkg_ffi.Utf8> rs2_get_option_value_description(
    ffi.Pointer<rs2_options> options,
    int option,
    double value,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_option_value_description(
      options,
      option,
      value,
      error,
    );
  }

  late final _rs2_get_option_value_descriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_options>,
                  ffi.Int32, ffi.Float, ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_option_value_description');
  late final _rs2_get_option_value_description =
      _rs2_get_option_value_descriptionPtr.asFunction<
          ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_options>, int,
              double, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// get the size of rs2_raw_data_buffer
  /// \param[in] buffer  pointer to rs2_raw_data_buffer returned by rs2_send_and_receive_raw_data
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return size of rs2_raw_data_buffer
  int rs2_get_raw_data_size(
    ffi.Pointer<rs2_raw_data_buffer> buffer,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_raw_data_size(
      buffer,
      error,
    );
  }

  late final _rs2_get_raw_data_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<rs2_raw_data_buffer>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_raw_data_size');
  late final _rs2_get_raw_data_size = _rs2_get_raw_data_sizePtr.asFunction<
      int Function(ffi.Pointer<rs2_raw_data_buffer>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Delete rs2_raw_data_buffer
  /// \param[in] buffer        rs2_raw_data_buffer returned by rs2_send_and_receive_raw_data
  void rs2_delete_raw_data(
    ffi.Pointer<rs2_raw_data_buffer> buffer,
  ) {
    return _rs2_delete_raw_data(
      buffer,
    );
  }

  late final _rs2_delete_raw_dataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<rs2_raw_data_buffer>)>>(
      'rs2_delete_raw_data');
  late final _rs2_delete_raw_data = _rs2_delete_raw_dataPtr
      .asFunction<void Function(ffi.Pointer<rs2_raw_data_buffer>)>();

  /// Retrieve char array from rs2_raw_data_buffer
  /// \param[in] buffer   rs2_raw_data_buffer returned by rs2_send_and_receive_raw_data
  /// \param[out] error   if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return raw data
  ffi.Pointer<ffi.UnsignedChar> rs2_get_raw_data(
    ffi.Pointer<rs2_raw_data_buffer> buffer,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_raw_data(
      buffer,
      error,
    );
  }

  late final _rs2_get_raw_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<rs2_raw_data_buffer>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_raw_data');
  late final _rs2_get_raw_data = _rs2_get_raw_dataPtr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(ffi.Pointer<rs2_raw_data_buffer>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Retrieve the API version from the source code. Evaluate that the value is conformant to the established policies
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return            the version API encoded into integer value "1.9.3" -> 10903
  int rs2_get_api_version(
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_api_version(
      error,
    );
  }

  late final _rs2_get_api_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_api_version');
  late final _rs2_get_api_version = _rs2_get_api_versionPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  void rs2_log_to_console(
    int min_severity,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_log_to_console(
      min_severity,
      error,
    );
  }

  late final _rs2_log_to_consolePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_log_to_console');
  late final _rs2_log_to_console = _rs2_log_to_consolePtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  void rs2_log_to_file(
    int min_severity,
    ffi.Pointer<pkg_ffi.Utf8> file_path,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_log_to_file(
      min_severity,
      file_path,
      error,
    );
  }

  late final _rs2_log_to_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<pkg_ffi.Utf8>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_log_to_file');
  late final _rs2_log_to_file = _rs2_log_to_filePtr.asFunction<
      void Function(int, ffi.Pointer<pkg_ffi.Utf8>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  void rs2_log_to_callback_cpp(
    int min_severity,
    ffi.Pointer<rs2_log_callback> callback,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_log_to_callback_cpp(
      min_severity,
      callback,
      error,
    );
  }

  late final _rs2_log_to_callback_cppPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<rs2_log_callback>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_log_to_callback_cpp');
  late final _rs2_log_to_callback_cpp = _rs2_log_to_callback_cppPtr.asFunction<
      void Function(int, ffi.Pointer<rs2_log_callback>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  void rs2_log_to_callback(
    int min_severity,
    rs2_log_callback_ptr callback,
    ffi.Pointer<ffi.Void> arg,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_log_to_callback(
      min_severity,
      callback,
      arg,
      error,
    );
  }

  late final _rs2_log_to_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Int32,
              rs2_log_callback_ptr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_log_to_callback');
  late final _rs2_log_to_callback = _rs2_log_to_callbackPtr.asFunction<
      void Function(int, rs2_log_callback_ptr, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  void rs2_reset_logger(
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_reset_logger(
      error,
    );
  }

  late final _rs2_reset_loggerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_reset_logger');
  late final _rs2_reset_logger = _rs2_reset_loggerPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Enable rolling log file when used with rs2_log_to_file:
  /// Upon reaching (max_size/2) bytes, the log will be renamed with an ".old" suffix and a new log created. Any
  /// previous .old file will be erased.
  /// Must have permissions to remove/rename files in log file directory.
  /// \param[in] max_size   max file size in megabytes
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_enable_rolling_log_file(
    int max_size,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_enable_rolling_log_file(
      max_size,
      error,
    );
  }

  late final _rs2_enable_rolling_log_filePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.UnsignedInt, ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_enable_rolling_log_file');
  late final _rs2_enable_rolling_log_file = _rs2_enable_rolling_log_filePtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  int rs2_get_log_message_line_number(
    ffi.Pointer<rs2_log_message> msg,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_log_message_line_number(
      msg,
      error,
    );
  }

  late final _rs2_get_log_message_line_numberPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<rs2_log_message>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_log_message_line_number');
  late final _rs2_get_log_message_line_number =
      _rs2_get_log_message_line_numberPtr.asFunction<
          int Function(ffi.Pointer<rs2_log_message>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_get_log_message_filename(
    ffi.Pointer<rs2_log_message> msg,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_log_message_filename(
      msg,
      error,
    );
  }

  late final _rs2_get_log_message_filenamePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_log_message>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_log_message_filename');
  late final _rs2_get_log_message_filename =
      _rs2_get_log_message_filenamePtr.asFunction<
          ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_log_message>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_get_raw_log_message(
    ffi.Pointer<rs2_log_message> msg,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_raw_log_message(
      msg,
      error,
    );
  }

  late final _rs2_get_raw_log_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_log_message>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_raw_log_message');
  late final _rs2_get_raw_log_message = _rs2_get_raw_log_messagePtr.asFunction<
      ffi.Pointer<pkg_ffi.Utf8> Function(
          ffi.Pointer<rs2_log_message>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  ffi.Pointer<pkg_ffi.Utf8> rs2_get_full_log_message(
    ffi.Pointer<rs2_log_message> msg,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_full_log_message(
      msg,
      error,
    );
  }

  late final _rs2_get_full_log_messagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_log_message>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_get_full_log_message');
  late final _rs2_get_full_log_message =
      _rs2_get_full_log_messagePtr.asFunction<
          ffi.Pointer<pkg_ffi.Utf8> Function(ffi.Pointer<rs2_log_message>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Add custom message into librealsense log
  /// \param[in] severity  The log level for the message to be written under
  /// \param[in] message   Message to be logged
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_log(
    int severity,
    ffi.Pointer<pkg_ffi.Utf8> message,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_log(
      severity,
      message,
      error,
    );
  }

  late final _rs2_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int32, ffi.Pointer<pkg_ffi.Utf8>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_log');
  late final _rs2_log = _rs2_logPtr.asFunction<
      void Function(int, ffi.Pointer<pkg_ffi.Utf8>,
          ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Given the 2D depth coordinate (x,y) provide the corresponding depth in metric units
  /// \param[in] frame_ref  2D depth pixel coordinates (Left-Upper corner origin)
  /// \param[in] x,y  2D depth pixel coordinates (Left-Upper corner origin)
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  double rs2_depth_frame_get_distance(
    ffi.Pointer<rs2_frame> frame_ref,
    int x,
    int y,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_depth_frame_get_distance(
      frame_ref,
      x,
      y,
      error,
    );
  }

  late final _rs2_depth_frame_get_distancePtr = _lookup<
          ffi.NativeFunction<
              ffi.Float Function(ffi.Pointer<rs2_frame>, ffi.Int, ffi.Int,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_depth_frame_get_distance');
  late final _rs2_depth_frame_get_distance =
      _rs2_depth_frame_get_distancePtr.asFunction<
          double Function(ffi.Pointer<rs2_frame>, int, int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// return the time at specific time point
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return            the time at specific time point, in live and record mode it will return the system time and in playback mode it will return the recorded time
  double rs2_get_time(
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_get_time(
      error,
    );
  }

  late final _rs2_get_timePtr = _lookup<
      ffi.NativeFunction<
          rs2_time_t Function(
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_get_time');
  late final _rs2_get_time = _rs2_get_timePtr
      .asFunction<double Function(ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Create a pipeline instance
  /// The pipeline simplifies the user interaction with the device and computer vision processing modules.
  /// The class abstracts the camera configuration and streaming, and the vision modules triggering and threading.
  /// It lets the application focus on the computer vision output of the modules, or the device output data.
  /// The pipeline can manage computer vision modules, which are implemented as a processing blocks.
  /// The pipeline is the consumer of the processing block interface, while the application consumes the
  /// computer vision interface.
  /// \param[in]  ctx    context
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  ffi.Pointer<rs2_pipeline> rs2_create_pipeline(
    ffi.Pointer<rs2_context> ctx,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_create_pipeline(
      ctx,
      error,
    );
  }

  late final _rs2_create_pipelinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rs2_pipeline> Function(ffi.Pointer<rs2_context>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_create_pipeline');
  late final _rs2_create_pipeline = _rs2_create_pipelinePtr.asFunction<
      ffi.Pointer<rs2_pipeline> Function(
          ffi.Pointer<rs2_context>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Stop the pipeline streaming.
  /// The pipeline stops delivering samples to the attached computer vision modules and processing blocks, stops the device streaming
  /// and releases the device resources used by the pipeline. It is the application's responsibility to release any frame reference it owns.
  /// The method takes effect only after \c start() was called, otherwise an exception is raised.
  /// \param[in] pipe  pipeline
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  void rs2_pipeline_stop(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_stop(
      pipe,
      error,
    );
  }

  late final _rs2_pipeline_stopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_pipeline_stop');
  late final _rs2_pipeline_stop = _rs2_pipeline_stopPtr.asFunction<
      void Function(
          ffi.Pointer<rs2_pipeline>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Wait until a new set of frames becomes available.
  /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
  /// The method blocks the calling thread, and fetches the latest unread frames set.
  /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
  /// as fast as the device frame rate.
  /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
  /// may lack memory resources to produce new frames, and the following call to this method shall fail to retrieve new frames, until resources
  /// are retained.
  /// \param[in] pipe the pipeline
  /// \param[in] timeout_ms   Max time in milliseconds to wait until an exception will be thrown
  /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return Set of coherent frames
  ffi.Pointer<rs2_frame> rs2_pipeline_wait_for_frames(
    ffi.Pointer<rs2_pipeline> pipe,
    int timeout_ms,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_wait_for_frames(
      pipe,
      timeout_ms,
      error,
    );
  }

  late final _rs2_pipeline_wait_for_framesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_frame> Function(ffi.Pointer<rs2_pipeline>,
                  ffi.UnsignedInt, ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_wait_for_frames');
  late final _rs2_pipeline_wait_for_frames =
      _rs2_pipeline_wait_for_framesPtr.asFunction<
          ffi.Pointer<rs2_frame> Function(ffi.Pointer<rs2_pipeline>, int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Check if a new set of frames is available and retrieve the latest undelivered set.
  /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
  /// The method returns without blocking the calling thread, with status of new frames available or not. If available, it fetches the
  /// latest frames set.
  /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
  /// as fast as the device frame rate.
  /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
  /// may lack memory resources to produce new frames, and the following calls to this method shall return no new frames, until resources are
  /// retained.
  /// \param[in] pipe the pipeline
  /// \param[out] output_frame frame handle to be released using rs2_release_frame
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return true if new frame was stored to output_frame
  int rs2_pipeline_poll_for_frames(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<ffi.Pointer<rs2_frame>> output_frame,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_poll_for_frames(
      pipe,
      output_frame,
      error,
    );
  }

  late final _rs2_pipeline_poll_for_framesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<rs2_pipeline>,
                  ffi.Pointer<ffi.Pointer<rs2_frame>>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_poll_for_frames');
  late final _rs2_pipeline_poll_for_frames =
      _rs2_pipeline_poll_for_framesPtr.asFunction<
          int Function(
              ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<ffi.Pointer<rs2_frame>>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Wait until a new set of frames becomes available.
  /// The frames set includes time-synchronized frames of each enabled stream in the pipeline.
  /// The method blocks the calling thread, and fetches the latest unread frames set.
  /// Device frames, which were produced while the function wasn't called, are dropped. To avoid frame drops, this method should be called
  /// as fast as the device frame rate.
  /// The application can maintain the frames handles to defer processing. However, if the application maintains too long history, the device
  /// may lack memory resources to produce new frames, and the following call to this method shall fail to retrieve new frames, until resources
  /// are retained.
  /// \param[in] pipe           the pipeline
  /// \param[in] timeout_ms     max time in milliseconds to wait until a frame becomes available
  /// \param[out] output_frame  frame handle to be released using rs2_release_frame
  /// \param[out] error         if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return true if new frame was stored to output_frame
  int rs2_pipeline_try_wait_for_frames(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<ffi.Pointer<rs2_frame>> output_frame,
    int timeout_ms,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_try_wait_for_frames(
      pipe,
      output_frame,
      timeout_ms,
      error,
    );
  }

  late final _rs2_pipeline_try_wait_for_framesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<rs2_pipeline>,
                  ffi.Pointer<ffi.Pointer<rs2_frame>>,
                  ffi.UnsignedInt,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_try_wait_for_frames');
  late final _rs2_pipeline_try_wait_for_frames =
      _rs2_pipeline_try_wait_for_framesPtr.asFunction<
          int Function(
              ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<ffi.Pointer<rs2_frame>>,
              int,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Delete a pipeline instance.
  /// Upon destruction, the pipeline will implicitly stop itself
  /// \param[in] pipe to delete
  void rs2_delete_pipeline(
    ffi.Pointer<rs2_pipeline> pipe,
  ) {
    return _rs2_delete_pipeline(
      pipe,
    );
  }

  late final _rs2_delete_pipelinePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<rs2_pipeline>)>>(
          'rs2_delete_pipeline');
  late final _rs2_delete_pipeline = _rs2_delete_pipelinePtr
      .asFunction<void Function(ffi.Pointer<rs2_pipeline>)>();

  /// Start the pipeline streaming with its default configuration.
  /// The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules
  /// and processing blocks, according to each module requirements and threading model.
  /// During the loop execution, the application can access the camera streams by calling \c wait_for_frames() or \c poll_for_frames().
  /// The streaming loop runs until the pipeline is stopped.
  /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
  ///
  /// \param[in] pipe    a pointer to an instance of the pipeline
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
  ffi.Pointer<rs2_pipeline_profile> rs2_pipeline_start(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_start(
      pipe,
      error,
    );
  }

  late final _rs2_pipeline_startPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<rs2_pipeline_profile> Function(ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>>('rs2_pipeline_start');
  late final _rs2_pipeline_start = _rs2_pipeline_startPtr.asFunction<
      ffi.Pointer<rs2_pipeline_profile> Function(
          ffi.Pointer<rs2_pipeline>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Start the pipeline streaming according to the configuraion.
  /// The pipeline streaming loop captures samples from the device, and delivers them to the attached computer vision modules
  /// and processing blocks, according to each module requirements and threading model.
  /// During the loop execution, the application can access the camera streams by calling \c wait_for_frames() or \c poll_for_frames().
  /// The streaming loop runs until the pipeline is stopped.
  /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
  /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
  /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
  /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
  /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
  /// or disconnected, or another application acquires ownership of a device.
  ///
  /// \param[in] pipe    a pointer to an instance of the pipeline
  /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
  ffi.Pointer<rs2_pipeline_profile> rs2_pipeline_start_with_config(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<rs2_config> config,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_start_with_config(
      pipe,
      config,
      error,
    );
  }

  late final _rs2_pipeline_start_with_configPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_pipeline_profile> Function(
                  ffi.Pointer<rs2_pipeline>,
                  ffi.Pointer<rs2_config>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_start_with_config');
  late final _rs2_pipeline_start_with_config =
      _rs2_pipeline_start_with_configPtr.asFunction<
          ffi.Pointer<rs2_pipeline_profile> Function(ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<rs2_config>, ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Start the pipeline streaming with its default configuration.
  /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
  /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
  /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
  ///
  /// \param[in] pipe     A pointer to an instance of the pipeline
  /// \param[in] on_frame function pointer to register as per-frame callback
  /// \param[in] user auxiliary  data the user wishes to receive together with every frame callback
  /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
  ffi.Pointer<rs2_pipeline_profile> rs2_pipeline_start_with_callback(
    ffi.Pointer<rs2_pipeline> pipe,
    rs2_frame_callback_ptr on_frame,
    ffi.Pointer<ffi.Void> user,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_start_with_callback(
      pipe,
      on_frame,
      user,
      error,
    );
  }

  late final _rs2_pipeline_start_with_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_pipeline_profile> Function(
                  ffi.Pointer<rs2_pipeline>,
                  rs2_frame_callback_ptr,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_start_with_callback');
  late final _rs2_pipeline_start_with_callback =
      _rs2_pipeline_start_with_callbackPtr.asFunction<
          ffi.Pointer<rs2_pipeline_profile> Function(
              ffi.Pointer<rs2_pipeline>,
              rs2_frame_callback_ptr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Start the pipeline streaming with its default configuration.
  /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
  /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
  /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
  ///
  /// \param[in] pipe     A pointer to an instance of the pipeline
  /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant streaming lock
  /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
  ffi.Pointer<rs2_pipeline_profile> rs2_pipeline_start_with_callback_cpp(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<rs2_frame_callback> callback,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_start_with_callback_cpp(
      pipe,
      callback,
      error,
    );
  }

  late final _rs2_pipeline_start_with_callback_cppPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_pipeline_profile> Function(
                  ffi.Pointer<rs2_pipeline>,
                  ffi.Pointer<rs2_frame_callback>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_start_with_callback_cpp');
  late final _rs2_pipeline_start_with_callback_cpp =
      _rs2_pipeline_start_with_callback_cppPtr.asFunction<
          ffi.Pointer<rs2_pipeline_profile> Function(
              ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<rs2_frame_callback>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Start the pipeline streaming according to the configuraion.
  /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
  /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
  /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
  /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
  /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
  /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
  /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
  /// or disconnected, or another application acquires ownership of a device.
  ///
  /// \param[in] pipe     A pointer to an instance of the pipeline
  /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
  /// \param[in] on_frame function pointer to register as per-frame callback
  /// \param[in] user auxiliary  data the user wishes to receive together with every frame callback
  /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
  ffi.Pointer<rs2_pipeline_profile> rs2_pipeline_start_with_config_and_callback(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<rs2_config> config,
    rs2_frame_callback_ptr on_frame,
    ffi.Pointer<ffi.Void> user,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_start_with_config_and_callback(
      pipe,
      config,
      on_frame,
      user,
      error,
    );
  }

  late final _rs2_pipeline_start_with_config_and_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_pipeline_profile> Function(
                  ffi.Pointer<rs2_pipeline>,
                  ffi.Pointer<rs2_config>,
                  rs2_frame_callback_ptr,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_start_with_config_and_callback');
  late final _rs2_pipeline_start_with_config_and_callback =
      _rs2_pipeline_start_with_config_and_callbackPtr.asFunction<
          ffi.Pointer<rs2_pipeline_profile> Function(
              ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<rs2_config>,
              rs2_frame_callback_ptr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Start the pipeline streaming according to the configuraion.
  /// The pipeline captures samples from the device, and delivers them to the through the provided frame callback.
  /// Starting the pipeline is possible only when it is not started. If the pipeline was started, an exception is raised.
  /// When starting the pipeline with a callback both \c wait_for_frames() or \c poll_for_frames() will throw exception.
  /// The pipeline selects and activates the device upon start, according to configuration or a default configuration.
  /// When the rs2::config is provided to the method, the pipeline tries to activate the config \c resolve() result. If the application
  /// requests are conflicting with pipeline computer vision modules or no matching device is available on the platform, the method fails.
  /// Available configurations and devices may change between config \c resolve() call and pipeline start, in case devices are connected
  /// or disconnected, or another application acquires ownership of a device.
  ///
  /// \param[in] pipe     A pointer to an instance of the pipeline
  /// \param[in] config   A rs2::config with requested filters on the pipeline configuration. By default no filters are applied.
  /// \param[in] callback callback object created from c++ application. ownership over the callback object is moved into the relevant streaming lock
  /// \param[out] error   If non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return             The actual pipeline device and streams profile, which was successfully configured to the streaming device.
  ffi.Pointer<rs2_pipeline_profile>
      rs2_pipeline_start_with_config_and_callback_cpp(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<rs2_config> config,
    ffi.Pointer<rs2_frame_callback> callback,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_start_with_config_and_callback_cpp(
      pipe,
      config,
      callback,
      error,
    );
  }

  late final _rs2_pipeline_start_with_config_and_callback_cppPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_pipeline_profile> Function(
                  ffi.Pointer<rs2_pipeline>,
                  ffi.Pointer<rs2_config>,
                  ffi.Pointer<rs2_frame_callback>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_start_with_config_and_callback_cpp');
  late final _rs2_pipeline_start_with_config_and_callback_cpp =
      _rs2_pipeline_start_with_config_and_callback_cppPtr.asFunction<
          ffi.Pointer<rs2_pipeline_profile> Function(
              ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<rs2_config>,
              ffi.Pointer<rs2_frame_callback>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Return the active device and streams profiles, used by the pipeline.
  /// The pipeline streams profiles are selected during \c start(). The method returns a valid result only when the pipeline is active -
  /// between calls to \c start() and \c stop().
  /// After \c stop() is called, the pipeline doesn't own the device, thus, the pipeline selected device may change in subsequent activations.
  ///
  /// \param[in] pipe    a pointer to an instance of the pipeline
  /// \param[out] error  if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return  The actual pipeline device and streams profile, which was successfully configured to the streaming device on start.
  ffi.Pointer<rs2_pipeline_profile> rs2_pipeline_get_active_profile(
    ffi.Pointer<rs2_pipeline> pipe,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_get_active_profile(
      pipe,
      error,
    );
  }

  late final _rs2_pipeline_get_active_profilePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_pipeline_profile> Function(
                  ffi.Pointer<rs2_pipeline>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_get_active_profile');
  late final _rs2_pipeline_get_active_profile =
      _rs2_pipeline_get_active_profilePtr.asFunction<
          ffi.Pointer<rs2_pipeline_profile> Function(ffi.Pointer<rs2_pipeline>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Retrieve the device used by the pipeline.
  /// The device class provides the application access to control camera additional settings -
  /// get device information, sensor options information, options value query and set, sensor specific extensions.
  /// Since the pipeline controls the device streams configuration, activation state and frames reading, calling
  /// the device API functions, which execute those operations, results in unexpected behavior.
  /// The pipeline streaming device is selected during pipeline \c start(). Devices of profiles, which are not returned by
  /// pipeline \c start() or \c get_active_profile(), are not guaranteed to be used by the pipeline.
  ///
  /// \param[in] profile    A pointer to an instance of a pipeline profile
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return rs2_device* The pipeline selected device
  ffi.Pointer<rs2_device> rs2_pipeline_profile_get_device(
    ffi.Pointer<rs2_pipeline_profile> profile,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_profile_get_device(
      profile,
      error,
    );
  }

  late final _rs2_pipeline_profile_get_devicePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_device> Function(
                  ffi.Pointer<rs2_pipeline_profile>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_profile_get_device');
  late final _rs2_pipeline_profile_get_device =
      _rs2_pipeline_profile_get_devicePtr.asFunction<
          ffi.Pointer<rs2_device> Function(ffi.Pointer<rs2_pipeline_profile>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Return the selected streams profiles, which are enabled in this profile.
  ///
  /// \param[in] profile    A pointer to an instance of a pipeline profile
  /// \param[out] error     if non-null, receives any error that occurs during this call, otherwise, errors are ignored
  /// \return   list of stream profiles
  ffi.Pointer<rs2_stream_profile_list> rs2_pipeline_profile_get_streams(
    ffi.Pointer<rs2_pipeline_profile> profile,
    ffi.Pointer<ffi.Pointer<rs2_error>> error,
  ) {
    return _rs2_pipeline_profile_get_streams(
      profile,
      error,
    );
  }

  late final _rs2_pipeline_profile_get_streamsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<rs2_stream_profile_list> Function(
                  ffi.Pointer<rs2_pipeline_profile>,
                  ffi.Pointer<ffi.Pointer<rs2_error>>)>>(
      'rs2_pipeline_profile_get_streams');
  late final _rs2_pipeline_profile_get_streams =
      _rs2_pipeline_profile_get_streamsPtr.asFunction<
          ffi.Pointer<rs2_stream_profile_list> Function(
              ffi.Pointer<rs2_pipeline_profile>,
              ffi.Pointer<ffi.Pointer<rs2_error>>)>();

  /// Deletes an instance of a pipeline profile
  ///
  /// \param[in] profile    A pointer to an instance of a pipeline profile
  void rs2_delete_pipeline_profile(
    ffi.Pointer<rs2_pipeline_profile> profile,
  ) {
    return _rs2_delete_pipeline_profile(
      profile,
    );
  }

  late final _rs2_delete_pipeline_profilePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<rs2_pipeline_profile>)>>(
      'rs2_delete_pipeline_profile');
  late final _rs2_delete_pipeline_profile = _rs2_delete_pipeline_profilePtr
      .asFunction<void Function(ffi.Pointer<rs2_pipeline_profile>)>();
}

/// \brief Specifies the clock in relation to which the frame timestamp was measured.
abstract class rs2_timestamp_domain {
  /// < Frame timestamp was measured in relation to the camera clock
  static const int RS2_TIMESTAMP_DOMAIN_HARDWARE_CLOCK = 0;

  /// < Frame timestamp was measured in relation to the OS system clock
  static const int RS2_TIMESTAMP_DOMAIN_SYSTEM_TIME = 1;

  /// < Frame timestamp was measured in relation to the camera clock and converted to OS system clock by constantly measure the difference
  static const int RS2_TIMESTAMP_DOMAIN_GLOBAL_TIME = 2;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_TIMESTAMP_DOMAIN_COUNT = 3;
}

/// \brief Per-Frame-Metadata is the set of read-only properties that might be exposed for each individual frame.
abstract class rs2_frame_metadata_value {
  /// < A sequential index managed per-stream. Integer value
  static const int RS2_FRAME_METADATA_FRAME_COUNTER = 0;

  /// < Timestamp set by device clock when data readout and transmit commence. usec
  static const int RS2_FRAME_METADATA_FRAME_TIMESTAMP = 1;

  /// < Timestamp of the middle of sensor's exposure calculated by device. usec
  static const int RS2_FRAME_METADATA_SENSOR_TIMESTAMP = 2;

  /// < Sensor's exposure width. When Auto Exposure (AE) is on the value is controlled by firmware. usec
  static const int RS2_FRAME_METADATA_ACTUAL_EXPOSURE = 3;

  /// < A relative value increasing which will increase the Sensor's gain factor. \
  /// When AE is set On, the value is controlled by firmware. Integer value
  static const int RS2_FRAME_METADATA_GAIN_LEVEL = 4;

  /// < Auto Exposure Mode indicator. Zero corresponds to AE switched off.
  static const int RS2_FRAME_METADATA_AUTO_EXPOSURE = 5;

  /// < White Balance setting as a color temperature. Kelvin degrees
  static const int RS2_FRAME_METADATA_WHITE_BALANCE = 6;

  /// < Time of arrival in system clock
  static const int RS2_FRAME_METADATA_TIME_OF_ARRIVAL = 7;

  /// < Temperature of the device, measured at the time of the frame capture. Celsius degrees
  static const int RS2_FRAME_METADATA_TEMPERATURE = 8;

  /// < Timestamp get from uvc driver. usec
  static const int RS2_FRAME_METADATA_BACKEND_TIMESTAMP = 9;

  /// < Actual fps
  static const int RS2_FRAME_METADATA_ACTUAL_FPS = 10;

  /// < Laser power value 0-360.
  static const int RS2_FRAME_METADATA_FRAME_LASER_POWER = 11;

  /// < Laser power mode. Zero corresponds to Laser power switched off and one for switched on. deprecated, replaced by RS2_FRAME_METADATA_FRAME_EMITTER_MODE
  static const int RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE = 12;

  /// < Exposure priority.
  static const int RS2_FRAME_METADATA_EXPOSURE_PRIORITY = 13;

  /// < Left region of interest for the auto exposure Algorithm.
  static const int RS2_FRAME_METADATA_EXPOSURE_ROI_LEFT = 14;

  /// < Right region of interest for the auto exposure Algorithm.
  static const int RS2_FRAME_METADATA_EXPOSURE_ROI_RIGHT = 15;

  /// < Top region of interest for the auto exposure Algorithm.
  static const int RS2_FRAME_METADATA_EXPOSURE_ROI_TOP = 16;

  /// < Bottom region of interest for the auto exposure Algorithm.
  static const int RS2_FRAME_METADATA_EXPOSURE_ROI_BOTTOM = 17;

  /// < Color image brightness.
  static const int RS2_FRAME_METADATA_BRIGHTNESS = 18;

  /// < Color image contrast.
  static const int RS2_FRAME_METADATA_CONTRAST = 19;

  /// < Color image saturation.
  static const int RS2_FRAME_METADATA_SATURATION = 20;

  /// < Color image sharpness.
  static const int RS2_FRAME_METADATA_SHARPNESS = 21;

  /// < Auto white balance temperature Mode indicator. Zero corresponds to automatic mode switched off.
  static const int RS2_FRAME_METADATA_AUTO_WHITE_BALANCE_TEMPERATURE = 22;

  /// < Color backlight compensation. Zero corresponds to switched off.
  static const int RS2_FRAME_METADATA_BACKLIGHT_COMPENSATION = 23;

  /// < Color image hue.
  static const int RS2_FRAME_METADATA_HUE = 24;

  /// < Color image gamma.
  static const int RS2_FRAME_METADATA_GAMMA = 25;

  /// < Color image white balance.
  static const int RS2_FRAME_METADATA_MANUAL_WHITE_BALANCE = 26;

  /// < Power Line Frequency for anti-flickering Off/50Hz/60Hz/Auto.
  static const int RS2_FRAME_METADATA_POWER_LINE_FREQUENCY = 27;

  /// < Color lowlight compensation. Zero corresponds to switched off.
  static const int RS2_FRAME_METADATA_LOW_LIGHT_COMPENSATION = 28;

  /// < Emitter mode: 0 - all emitters disabled. 1 - laser enabled. 2 - auto laser enabled (opt). 3 - LED enabled (opt).
  static const int RS2_FRAME_METADATA_FRAME_EMITTER_MODE = 29;

  /// < Led power value 0-360.
  static const int RS2_FRAME_METADATA_FRAME_LED_POWER = 30;

  /// < The number of transmitted payload bytes, not including metadata
  static const int RS2_FRAME_METADATA_RAW_FRAME_SIZE = 31;

  /// < GPIO input data
  static const int RS2_FRAME_METADATA_GPIO_INPUT_DATA = 32;

  /// < sub-preset id
  static const int RS2_FRAME_METADATA_SEQUENCE_NAME = 33;

  /// < sub-preset sequence id
  static const int RS2_FRAME_METADATA_SEQUENCE_ID = 34;

  /// < sub-preset sequence size
  static const int RS2_FRAME_METADATA_SEQUENCE_SIZE = 35;

  /// < Frame trigger type
  static const int RS2_FRAME_METADATA_TRIGGER = 36;

  /// < Preset id, used in MIPI SKU Metadata
  static const int RS2_FRAME_METADATA_PRESET = 37;

  /// < Frame input width in pixels, used as safety attribute
  static const int RS2_FRAME_METADATA_INPUT_WIDTH = 38;

  /// < Frame input height in pixels, used as safety attribute
  static const int RS2_FRAME_METADATA_INPUT_HEIGHT = 39;

  /// < Sub-preset information
  static const int RS2_FRAME_METADATA_SUB_PRESET_INFO = 40;

  /// < FW-controlled frame counter to be using in Calibration scenarios
  static const int RS2_FRAME_METADATA_CALIB_INFO = 41;

  /// < CRC checksum of the Metadata
  static const int RS2_FRAME_METADATA_CRC = 42;
  static const int RS2_FRAME_METADATA_COUNT = 43;
}

/// \brief Calibration target type.
abstract class rs2_calib_target_type {
  /// < Flat rectangle with vertices as the centers of Gaussian dots
  static const int RS2_CALIB_TARGET_RECT_GAUSSIAN_DOT_VERTICES = 0;

  /// < Flat rectangle with vertices as the centers of Gaussian dots with target inside the ROI
  static const int RS2_CALIB_TARGET_ROI_RECT_GAUSSIAN_DOT_VERTICES = 1;

  /// < Positions of vertices as the centers of Gaussian dots with target inside the ROI
  static const int RS2_CALIB_TARGET_POS_GAUSSIAN_DOT_VERTICES = 2;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_CALIB_TARGET_COUNT = 3;
}

typedef rs2_metadata_type = ffi.LongLong;

final class rs2_frame extends ffi.Opaque {}

final class rs2_error extends ffi.Opaque {}

typedef rs2_time_t = ffi.Double;

final class rs2_sensor extends ffi.Opaque {}

/// \brief 3D coordinates with origin at topmost left corner of the lense,
/// with positive Z pointing away from the camera, positive X pointing camera right and positive Y pointing camera down
final class rs2_vertex extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Float> xyz;
}

/// \brief Pixel location within 2D image. (0,0) is the topmost, left corner. Positive X is right, positive Y is down
final class rs2_pixel extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> ij;
}

final class rs2_stream_profile extends ffi.Opaque {}

/// \brief Specifies advanced interfaces (capabilities) objects may implement.
abstract class rs2_extension {
  static const int RS2_EXTENSION_UNKNOWN = 0;
  static const int RS2_EXTENSION_DEBUG = 1;
  static const int RS2_EXTENSION_INFO = 2;
  static const int RS2_EXTENSION_MOTION = 3;
  static const int RS2_EXTENSION_OPTIONS = 4;
  static const int RS2_EXTENSION_VIDEO = 5;
  static const int RS2_EXTENSION_ROI = 6;
  static const int RS2_EXTENSION_DEPTH_SENSOR = 7;
  static const int RS2_EXTENSION_VIDEO_FRAME = 8;
  static const int RS2_EXTENSION_MOTION_FRAME = 9;
  static const int RS2_EXTENSION_COMPOSITE_FRAME = 10;
  static const int RS2_EXTENSION_POINTS = 11;
  static const int RS2_EXTENSION_DEPTH_FRAME = 12;
  static const int RS2_EXTENSION_ADVANCED_MODE = 13;
  static const int RS2_EXTENSION_RECORD = 14;
  static const int RS2_EXTENSION_VIDEO_PROFILE = 15;
  static const int RS2_EXTENSION_PLAYBACK = 16;
  static const int RS2_EXTENSION_DEPTH_STEREO_SENSOR = 17;
  static const int RS2_EXTENSION_DISPARITY_FRAME = 18;
  static const int RS2_EXTENSION_MOTION_PROFILE = 19;
  static const int RS2_EXTENSION_POSE_FRAME = 20;
  static const int RS2_EXTENSION_POSE_PROFILE = 21;
  static const int RS2_EXTENSION_TM2 = 22;
  static const int RS2_EXTENSION_SOFTWARE_DEVICE = 23;
  static const int RS2_EXTENSION_SOFTWARE_SENSOR = 24;
  static const int RS2_EXTENSION_DECIMATION_FILTER = 25;
  static const int RS2_EXTENSION_THRESHOLD_FILTER = 26;
  static const int RS2_EXTENSION_DISPARITY_FILTER = 27;
  static const int RS2_EXTENSION_SPATIAL_FILTER = 28;
  static const int RS2_EXTENSION_TEMPORAL_FILTER = 29;
  static const int RS2_EXTENSION_HOLE_FILLING_FILTER = 30;
  static const int RS2_EXTENSION_ZERO_ORDER_FILTER = 31;
  static const int RS2_EXTENSION_RECOMMENDED_FILTERS = 32;
  static const int RS2_EXTENSION_POSE = 33;
  static const int RS2_EXTENSION_POSE_SENSOR = 34;
  static const int RS2_EXTENSION_WHEEL_ODOMETER = 35;
  static const int RS2_EXTENSION_GLOBAL_TIMER = 36;
  static const int RS2_EXTENSION_UPDATABLE = 37;
  static const int RS2_EXTENSION_UPDATE_DEVICE = 38;
  static const int RS2_EXTENSION_L500_DEPTH_SENSOR = 39;
  static const int RS2_EXTENSION_TM2_SENSOR = 40;
  static const int RS2_EXTENSION_AUTO_CALIBRATED_DEVICE = 41;
  static const int RS2_EXTENSION_COLOR_SENSOR = 42;
  static const int RS2_EXTENSION_MOTION_SENSOR = 43;
  static const int RS2_EXTENSION_FISHEYE_SENSOR = 44;

  /// DEPRECATED
  static const int RS2_EXTENSION_DEPTH_HUFFMAN_DECODER = 45;
  static const int RS2_EXTENSION_SERIALIZABLE = 46;
  static const int RS2_EXTENSION_FW_LOGGER = 47;
  static const int RS2_EXTENSION_AUTO_CALIBRATION_FILTER = 48;
  static const int RS2_EXTENSION_DEVICE_CALIBRATION = 49;
  static const int RS2_EXTENSION_CALIBRATED_SENSOR = 50;
  static const int RS2_EXTENSION_HDR_MERGE = 51;
  static const int RS2_EXTENSION_SEQUENCE_ID_FILTER = 52;
  static const int RS2_EXTENSION_MAX_USABLE_RANGE_SENSOR = 53;
  static const int RS2_EXTENSION_DEBUG_STREAM_SENSOR = 54;
  static const int RS2_EXTENSION_CALIBRATION_CHANGE_DEVICE = 55;
  static const int RS2_EXTENSION_COUNT = 56;
}

final class rs2_source extends ffi.Opaque {}

final class rs2_pose extends ffi.Struct {
  /// < X, Y, Z values of translation, in meters (relative to initial position)
  external rs2_vector translation;

  /// < X, Y, Z values of velocity, in meters/sec
  external rs2_vector velocity;

  /// < X, Y, Z values of acceleration, in meters/sec^2
  external rs2_vector acceleration;

  /// < Qi, Qj, Qk, Qr components of rotation as represented in quaternion rotation (relative to initial position)
  external rs2_quaternion rotation;

  /// < X, Y, Z values of angular velocity, in radians/sec
  external rs2_vector angular_velocity;

  /// < X, Y, Z values of angular acceleration, in radians/sec^2
  external rs2_vector angular_acceleration;

  /// < Pose confidence 0x0 - Failed, 0x1 - Low, 0x2 - Medium, 0x3 - High
  @ffi.UnsignedInt()
  external int tracker_confidence;

  /// < Pose map confidence 0x0 - Failed, 0x1 - Low, 0x2 - Medium, 0x3 - High
  @ffi.UnsignedInt()
  external int mapper_confidence;
}

/// \brief 3D vector in Euclidean coordinate space
final class rs2_vector extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double z;
}

/// \brief Quaternion used to represent rotation
final class rs2_quaternion extends ffi.Struct {
  @ffi.Float()
  external double x;

  @ffi.Float()
  external double y;

  @ffi.Float()
  external double z;

  @ffi.Float()
  external double w;
}

/// \brief Defines general configuration controls.
/// These can generally be mapped to camera UVC controls, and can be set / queried at any time unless stated otherwise.
abstract class rs2_option {
  /// < Enable / disable color backlight compensation
  static const int RS2_OPTION_BACKLIGHT_COMPENSATION = 0;

  /// < Color image brightness
  static const int RS2_OPTION_BRIGHTNESS = 1;

  /// < Color image contrast
  static const int RS2_OPTION_CONTRAST = 2;

  /// < Controls exposure time of color camera. Setting any value will disable auto exposure
  static const int RS2_OPTION_EXPOSURE = 3;

  /// < Color image gain
  static const int RS2_OPTION_GAIN = 4;

  /// < Color image gamma setting
  static const int RS2_OPTION_GAMMA = 5;

  /// < Color image hue
  static const int RS2_OPTION_HUE = 6;

  /// < Color image saturation setting
  static const int RS2_OPTION_SATURATION = 7;

  /// < Color image sharpness setting
  static const int RS2_OPTION_SHARPNESS = 8;

  /// < Controls white balance of color image. Setting any value will disable auto white balance
  static const int RS2_OPTION_WHITE_BALANCE = 9;

  /// < Enable / disable auto-exposure
  static const int RS2_OPTION_ENABLE_AUTO_EXPOSURE = 10;

  /// < Enable / disable color image auto-white-balance
  static const int RS2_OPTION_ENABLE_AUTO_WHITE_BALANCE = 11;

  /// < Provide access to several recommend sets of option presets for the depth camera
  static const int RS2_OPTION_VISUAL_PRESET = 12;

  /// < Power of the laser emitter (mW), with 0 meaning projector turned off
  static const int RS2_OPTION_LASER_POWER = 13;

  /// < Set the number of patterns projected per frame. The higher the accuracy value the more patterns projected. Increasing the number of patterns help to achieve better accuracy. Note that this control is affecting the Depth FPS
  static const int RS2_OPTION_ACCURACY = 14;

  /// < Motion vs. Range trade-off, with lower values allowing for better motion sensitivity and higher values allowing for better depth range
  static const int RS2_OPTION_MOTION_RANGE = 15;

  /// < Set the filter to apply to each depth frame. Each one of the filter is optimized per the application requirements
  static const int RS2_OPTION_FILTER_OPTION = 16;

  /// < The confidence level threshold used by the Depth algorithm pipe to set whether a pixel will get a valid range or will be marked with invalid range
  static const int RS2_OPTION_CONFIDENCE_THRESHOLD = 17;

  /// < Emitter select: 0 - disable all emitters. 1 - enable laser. 2 - enable auto laser. 3 - enable LED.
  static const int RS2_OPTION_EMITTER_ENABLED = 18;

  /// < Number of frames the user is allowed to keep per stream. Trying to hold-on to more frames will cause frame-drops.
  static const int RS2_OPTION_FRAMES_QUEUE_SIZE = 19;

  /// < Total number of detected frame drops from all streams
  static const int RS2_OPTION_TOTAL_FRAME_DROPS = 20;

  /// < Auto-Exposure modes: Static, Anti-Flicker and Hybrid
  static const int RS2_OPTION_AUTO_EXPOSURE_MODE = 21;

  /// < Power Line Frequency control for anti-flickering Off/50Hz/60Hz/Auto
  static const int RS2_OPTION_POWER_LINE_FREQUENCY = 22;

  /// < Current Asic Temperature
  static const int RS2_OPTION_ASIC_TEMPERATURE = 23;

  /// < disable error handling
  static const int RS2_OPTION_ERROR_POLLING_ENABLED = 24;

  /// < Current Projector Temperature
  static const int RS2_OPTION_PROJECTOR_TEMPERATURE = 25;

  /// < Enable / disable trigger to be outputed from the camera to any external device on every depth frame
  static const int RS2_OPTION_OUTPUT_TRIGGER_ENABLED = 26;

  /// < Current Motion-Module Temperature
  static const int RS2_OPTION_MOTION_MODULE_TEMPERATURE = 27;

  /// < Number of meters represented by a single depth unit
  static const int RS2_OPTION_DEPTH_UNITS = 28;

  /// < Enable/Disable automatic correction of the motion data
  static const int RS2_OPTION_ENABLE_MOTION_CORRECTION = 29;

  /// < Allows sensor to dynamically ajust the frame rate depending on lighting conditions
  static const int RS2_OPTION_AUTO_EXPOSURE_PRIORITY = 30;

  /// < Color scheme for data visualization
  static const int RS2_OPTION_COLOR_SCHEME = 31;

  /// < Perform histogram equalization post-processing on the depth data
  static const int RS2_OPTION_HISTOGRAM_EQUALIZATION_ENABLED = 32;

  /// < Minimal distance to the target
  static const int RS2_OPTION_MIN_DISTANCE = 33;

  /// < Maximum distance to the target
  static const int RS2_OPTION_MAX_DISTANCE = 34;

  /// < Texture mapping stream unique ID
  static const int RS2_OPTION_TEXTURE_SOURCE = 35;

  /// < The 2D-filter effect. The specific interpretation is given within the context of the filter
  static const int RS2_OPTION_FILTER_MAGNITUDE = 36;

  /// < 2D-filter parameter controls the weight/radius for smoothing.
  static const int RS2_OPTION_FILTER_SMOOTH_ALPHA = 37;

  /// < 2D-filter range/validity threshold
  static const int RS2_OPTION_FILTER_SMOOTH_DELTA = 38;

  /// < Enhance depth data post-processing with holes filling where appropriate
  static const int RS2_OPTION_HOLES_FILL = 39;

  /// < The distance in mm between the first and the second imagers in stereo-based depth cameras
  static const int RS2_OPTION_STEREO_BASELINE = 40;

  /// < Allows dynamically ajust the converge step value of the target exposure in Auto-Exposure algorithm
  static const int RS2_OPTION_AUTO_EXPOSURE_CONVERGE_STEP = 41;

  /// < Impose Inter-camera HW synchronization mode. Applicable for D400/L500/Rolling Shutter SKUs
  static const int RS2_OPTION_INTER_CAM_SYNC_MODE = 42;

  /// < Select a stream to process
  static const int RS2_OPTION_STREAM_FILTER = 43;

  /// < Select a stream format to process
  static const int RS2_OPTION_STREAM_FORMAT_FILTER = 44;

  /// < Select a stream index to process
  static const int RS2_OPTION_STREAM_INDEX_FILTER = 45;

  /// < When supported, this option make the camera to switch the emitter state every frame. 0 for disabled, 1 for enabled
  static const int RS2_OPTION_EMITTER_ON_OFF = 46;

  /// < Deprecated!!! - Zero order point x
  static const int RS2_OPTION_ZERO_ORDER_POINT_X = 47;

  /// < Deprecated!!! - Zero order point y
  static const int RS2_OPTION_ZERO_ORDER_POINT_Y = 48;

  /// < LDD temperature
  static const int RS2_OPTION_LLD_TEMPERATURE = 49;

  /// < MC temperature
  static const int RS2_OPTION_MC_TEMPERATURE = 50;

  /// < MA temperature
  static const int RS2_OPTION_MA_TEMPERATURE = 51;

  /// < Hardware stream configuration
  static const int RS2_OPTION_HARDWARE_PRESET = 52;

  /// < disable global time
  static const int RS2_OPTION_GLOBAL_TIME_ENABLED = 53;

  /// < APD temperature
  static const int RS2_OPTION_APD_TEMPERATURE = 54;

  /// < Enable an internal map
  static const int RS2_OPTION_ENABLE_MAPPING = 55;

  /// < Enable appearance based relocalization
  static const int RS2_OPTION_ENABLE_RELOCALIZATION = 56;

  /// < Enable position jumping
  static const int RS2_OPTION_ENABLE_POSE_JUMPING = 57;

  /// < Enable dynamic calibration
  static const int RS2_OPTION_ENABLE_DYNAMIC_CALIBRATION = 58;

  /// < Offset from sensor to depth origin in millimetrers
  static const int RS2_OPTION_DEPTH_OFFSET = 59;

  /// < Power of the LED (light emitting diode), with 0 meaning LED off
  static const int RS2_OPTION_LED_POWER = 60;

  /// < DEPRECATED! - Toggle Zero-Order mode
  static const int RS2_OPTION_ZERO_ORDER_ENABLED = 61;

  /// < Preserve previous map when starting
  static const int RS2_OPTION_ENABLE_MAP_PRESERVATION = 62;

  /// < Enable/disable sensor shutdown when a free-fall is detected (on by default)
  static const int RS2_OPTION_FREEFALL_DETECTION_ENABLED = 63;

  /// < Changes the exposure time of Avalanche Photo Diode in the receiver
  static const int RS2_OPTION_AVALANCHE_PHOTO_DIODE = 64;

  /// < Changes the amount of sharpening in the post-processed image
  static const int RS2_OPTION_POST_PROCESSING_SHARPENING = 65;

  /// < Changes the amount of sharpening in the pre-processed image
  static const int RS2_OPTION_PRE_PROCESSING_SHARPENING = 66;

  /// < Control edges and background noise
  static const int RS2_OPTION_NOISE_FILTERING = 67;

  /// < Enable\disable pixel invalidation
  static const int RS2_OPTION_INVALIDATION_BYPASS = 68;

  /// < DEPRECATED! - Use RS2_OPTION_DIGITAL_GAIN instead.
  static const int RS2_OPTION_AMBIENT_LIGHT = 69;

  /// < Change the depth digital gain see rs2_digital_gain for values
  static const int RS2_OPTION_DIGITAL_GAIN = 69;

  /// < The resolution mode: see rs2_sensor_mode for values
  static const int RS2_OPTION_SENSOR_MODE = 70;

  /// < Enable Laser On constantly (GS SKU Only)
  static const int RS2_OPTION_EMITTER_ALWAYS_ON = 71;

  /// < Depth Thermal Compensation for selected D400 SKUs
  static const int RS2_OPTION_THERMAL_COMPENSATION = 72;

  /// < DEPRECATED as of 2.46!
  static const int RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH = 73;

  /// < DEPRECATED as of 2.46!
  static const int RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH = 74;

  /// < Set host performance mode to optimize device settings so host can keep up with workload, for example, USB transaction granularity, setting option to low performance host leads to larger USB transaction size and reduced number of transactions which improves performance and stability if host is relatively weak as compared to workload
  static const int RS2_OPTION_HOST_PERFORMANCE = 75;

  /// < Enable / disable HDR
  static const int RS2_OPTION_HDR_ENABLED = 76;

  /// < HDR Sequence name
  static const int RS2_OPTION_SEQUENCE_NAME = 77;

  /// < HDR Sequence size
  static const int RS2_OPTION_SEQUENCE_SIZE = 78;

  /// < HDR Sequence ID - 0 is not HDR; sequence ID for HDR configuration starts from 1
  static const int RS2_OPTION_SEQUENCE_ID = 79;

  /// < Humidity temperature [Deg Celsius]
  static const int RS2_OPTION_HUMIDITY_TEMPERATURE = 80;

  /// < Turn on/off the maximum usable depth sensor range given the amount of ambient light in the scene
  static const int RS2_OPTION_ENABLE_MAX_USABLE_RANGE = 81;

  /// < Turn on/off the alternate IR, When enabling alternate IR, the IR image is holding the amplitude of the depth correlation.
  static const int RS2_OPTION_ALTERNATE_IR = 82;

  /// < Noise estimation - indicates the noise on the IR image
  static const int RS2_OPTION_NOISE_ESTIMATION = 83;

  /// < Enables data collection for calculating IR pixel reflectivity
  static const int RS2_OPTION_ENABLE_IR_REFLECTIVITY = 84;

  /// < Set and get auto exposure limit in microseconds. If the requested exposure limit is greater than frame time, it will be set to frame time at runtime. Setting will not take effect until next streaming session.
  static const int RS2_OPTION_AUTO_EXPOSURE_LIMIT = 85;

  /// < Set and get auto gain limits ranging from 16 to 248. If the requested gain limit is less than 16, it will be set to 16. If the requested gain limit is greater than 248, it will be set to 248. Setting will not take effect until next streaming session.
  static const int RS2_OPTION_AUTO_GAIN_LIMIT = 86;

  /// < Enable receiver sensitivity according to ambient light, bounded by the Receiver Gain control.
  static const int RS2_OPTION_AUTO_RX_SENSITIVITY = 87;

  /// < changes the transmitter frequencies increasing effective range over sharpness.
  static const int RS2_OPTION_TRANSMITTER_FREQUENCY = 88;

  /// < Enables vertical binning which increases the maximal sensed distance.
  static const int RS2_OPTION_VERTICAL_BINNING = 89;

  /// < Control receiver sensitivity to incoming light, both projected and ambient (same as APD on L515).
  static const int RS2_OPTION_RECEIVER_SENSITIVITY = 90;

  /// < Enable / disable color image auto-exposure
  static const int RS2_OPTION_AUTO_EXPOSURE_LIMIT_TOGGLE = 91;

  /// < Enable / disable color image auto-gain
  static const int RS2_OPTION_AUTO_GAIN_LIMIT_TOGGLE = 92;

  /// < Select emitter (laser projector) frequency, see rs2_emitter_frequency for values
  static const int RS2_OPTION_EMITTER_FREQUENCY = 93;

  /// < Select depth sensor auto exposure mode see rs2_depth_auto_exposure_mode for values
  static const int RS2_OPTION_DEPTH_AUTO_EXPOSURE_MODE = 94;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_OPTION_COUNT = 95;
}

/// \brief For SR300 devices: provides optimized settings (presets) for specific types of usage.
abstract class rs2_sr300_visual_preset {
  /// < Preset for short range
  static const int RS2_SR300_VISUAL_PRESET_SHORT_RANGE = 0;

  /// < Preset for long range
  static const int RS2_SR300_VISUAL_PRESET_LONG_RANGE = 1;

  /// < Preset for background segmentation
  static const int RS2_SR300_VISUAL_PRESET_BACKGROUND_SEGMENTATION = 2;

  /// < Preset for gesture recognition
  static const int RS2_SR300_VISUAL_PRESET_GESTURE_RECOGNITION = 3;

  /// < Preset for object scanning
  static const int RS2_SR300_VISUAL_PRESET_OBJECT_SCANNING = 4;

  /// < Preset for face analytics
  static const int RS2_SR300_VISUAL_PRESET_FACE_ANALYTICS = 5;

  /// < Preset for face login
  static const int RS2_SR300_VISUAL_PRESET_FACE_LOGIN = 6;

  /// < Preset for GR cursor
  static const int RS2_SR300_VISUAL_PRESET_GR_CURSOR = 7;

  /// < Camera default settings
  static const int RS2_SR300_VISUAL_PRESET_DEFAULT = 8;

  /// < Preset for mid-range
  static const int RS2_SR300_VISUAL_PRESET_MID_RANGE = 9;

  /// < Preset for IR only
  static const int RS2_SR300_VISUAL_PRESET_IR_ONLY = 10;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_SR300_VISUAL_PRESET_COUNT = 11;
}

/// \brief For RS400 devices: provides optimized settings (presets) for specific types of usage.
abstract class rs2_rs400_visual_preset {
  static const int RS2_RS400_VISUAL_PRESET_CUSTOM = 0;
  static const int RS2_RS400_VISUAL_PRESET_DEFAULT = 1;
  static const int RS2_RS400_VISUAL_PRESET_HAND = 2;
  static const int RS2_RS400_VISUAL_PRESET_HIGH_ACCURACY = 3;
  static const int RS2_RS400_VISUAL_PRESET_HIGH_DENSITY = 4;
  static const int RS2_RS400_VISUAL_PRESET_MEDIUM_DENSITY = 5;
  static const int RS2_RS400_VISUAL_PRESET_REMOVE_IR_PATTERN = 6;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_RS400_VISUAL_PRESET_COUNT = 7;
}

/// \brief For L500 devices: provides optimized settings (presets) for specific types of usage.
abstract class rs2_l500_visual_preset {
  static const int RS2_L500_VISUAL_PRESET_CUSTOM = 0;
  static const int RS2_L500_VISUAL_PRESET_DEFAULT = 1;
  static const int RS2_L500_VISUAL_PRESET_NO_AMBIENT = 2;
  static const int RS2_L500_VISUAL_PRESET_LOW_AMBIENT = 3;
  static const int RS2_L500_VISUAL_PRESET_MAX_RANGE = 4;
  static const int RS2_L500_VISUAL_PRESET_SHORT_RANGE = 5;
  static const int RS2_L500_VISUAL_PRESET_AUTOMATIC = 6;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_L500_VISUAL_PRESET_COUNT = 7;
}

/// \brief For setting the camera_mode option
abstract class rs2_sensor_mode {
  static const int RS2_SENSOR_MODE_VGA = 0;
  static const int RS2_SENSOR_MODE_XGA = 1;
  static const int RS2_SENSOR_MODE_QVGA = 2;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_SENSOR_MODE_COUNT = 3;
}

/// \brief  DEPRECATED! - Use RS2_OPTION_DIGITAL_GAIN instead.
abstract class rs2_ambient_light {
  static const int RS2_AMBIENT_LIGHT_NO_AMBIENT = 1;
  static const int RS2_AMBIENT_LIGHT_LOW_AMBIENT = 2;
}

/// \brief digital gain for RS2_OPTION_DIGITAL_GAIN option.
abstract class rs2_digital_gain {
  static const int RS2_DIGITAL_GAIN_AUTO = 0;
  static const int RS2_DIGITAL_GAIN_HIGH = 1;
  static const int RS2_DIGITAL_GAIN_LOW = 2;
}

/// \brief values for RS2_OPTION_HOST_PERFORMANCE option.
abstract class rs2_host_perf_mode {
  /// < no change in settings, use device defaults
  static const int RS2_HOST_PERF_DEFAULT = 0;

  /// < low performance host mode, if host cannot keep up with workload, this option may improve stability, for example, it sets larger USB transaction granularity, reduces number of transactions and improve performance and stability on relatively weak hosts as compared to the workload
  static const int RS2_HOST_PERF_LOW = 1;

  /// < high performance host mode, if host is strong as compared to the work and can handle workload without delay, this option sets smaller USB transactions granularity and as result larger number of transactions and workload on host, but reduces chance in device frame drops
  static const int RS2_HOST_PERF_HIGH = 2;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_HOST_PERF_COUNT = 3;
}

/// \brief values for RS2_EMITTER_FREQUENCY option.
abstract class rs2_emitter_frequency_mode {
  /// < Emitter frequency shall be 57 [KHZ]
  static const int RS2_EMITTER_FREQUENCY_57_KHZ = 0;

  /// < Emitter frequency shall be 91 [KHZ]
  static const int RS2_EMITTER_FREQUENCY_91_KHZ = 1;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_EMITTER_FREQUENCY_COUNT = 2;
}

/// \brief values for RS2_OPTION_DEPTH_AUTO_EXPOSURE_MODE option.
abstract class rs2_depth_auto_exposure_mode {
  /// < Choose regular algorithm for auto exposure
  static const int RS2_DEPTH_AUTO_EXPOSURE_REGULAR = 0;

  /// < Choose accelerated algorithm for auto exposure
  static const int RS2_DEPTH_AUTO_EXPOSURE_ACCELERATED = 1;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_DEPTH_AUTO_EXPOSURE_COUNT = 2;
}

final class rs2_options extends ffi.Opaque {}

final class rs2_options_list extends ffi.Opaque {}

final class rs2_raw_data_buffer extends ffi.Opaque {}

/// \brief Severity of the librealsense logger.
abstract class rs2_log_severity {
  /// < Detailed information about ordinary operations
  static const int RS2_LOG_SEVERITY_DEBUG = 0;

  /// < Terse information about ordinary operations
  static const int RS2_LOG_SEVERITY_INFO = 1;

  /// < Indication of possible failure
  static const int RS2_LOG_SEVERITY_WARN = 2;

  /// < Indication of definite failure
  static const int RS2_LOG_SEVERITY_ERROR = 3;

  /// < Indication of unrecoverable failure
  static const int RS2_LOG_SEVERITY_FATAL = 4;

  /// < No logging will occur
  static const int RS2_LOG_SEVERITY_NONE = 5;

  /// < Number of enumeration values. Not a valid input: intended to be used in for-loops.
  static const int RS2_LOG_SEVERITY_COUNT = 6;

  /// < Include any/all log messages
  static const int RS2_LOG_SEVERITY_ALL = 0;
}

final class rs2_log_callback extends ffi.Opaque {}

typedef rs2_log_callback_ptr = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Int32, ffi.Pointer<rs2_log_message>, ffi.Pointer<ffi.Void>)>>;

final class rs2_log_message extends ffi.Opaque {}

final class rs2_pipeline extends ffi.Opaque {}

final class rs2_context extends ffi.Opaque {}

final class rs2_pipeline_profile extends ffi.Opaque {}

final class rs2_config extends ffi.Opaque {}

typedef rs2_frame_callback_ptr = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<rs2_frame>, ffi.Pointer<ffi.Void>)>>;

final class rs2_frame_callback extends ffi.Opaque {}

final class rs2_device extends ffi.Opaque {}

final class rs2_stream_profile_list extends ffi.Opaque {}

const int RS2_API_MAJOR_VERSION = 2;

const int RS2_API_MINOR_VERSION = 54;

const int RS2_API_PATCH_VERSION = 2;

const int RS2_API_BUILD_VERSION = 0;

const int RS2_API_VERSION = 25402;
